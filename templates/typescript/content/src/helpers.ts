/**
 * Helper library for building MCP tool handlers in TypeScript
 * Uses the types generated by jco from WIT files for full type safety
 */

// Import generated MCP types
import type {
  Tool,
  ToolResult,
  ListToolsRequest,
  ListToolsResponse,
  CallToolRequest,
} from './generated/interfaces/fastertools-mcp-tools.js';

import type {
  ContentBlock,
  TextContent,
} from './generated/interfaces/fastertools-mcp-types.js';

import type {
  InitializeRequest,
  InitializeResponse,
  ServerCapabilities,
  ImplementationInfo,
  ProtocolVersion,
  ToolsCapability,
} from './generated/interfaces/fastertools-mcp-session-types.js';

import type {
  ProviderAuthConfig,
} from './generated/interfaces/fastertools-mcp-authorization-types.js';

// ==============================================================================
// APPLICATION-SPECIFIC TYPE DEFINITIONS
// ==============================================================================

// Weather-specific types for this example
export interface GeocodingResult {
  readonly results?: readonly {
    readonly name: string;
    readonly country: string;
    readonly latitude: number;
    readonly longitude: number;
  }[];
}

export interface WeatherApiResponse {
  readonly current: {
    readonly temperature_2m: number;
    readonly apparent_temperature: number;
    readonly relative_humidity_2m: number;
    readonly wind_speed_10m: number;
    readonly weather_code: number;
  };
}

// Tool argument types
export interface EchoArgs {
  readonly message: string;
}

export interface WeatherArgs {
  readonly location: string;
}

export interface MultiWeatherArgs {
  readonly cities: readonly string[];
}

// ==============================================================================
// TOOL DEFINITION HELPER
// ==============================================================================

export interface ToolDefinition<TArgs = any> {
  readonly name: string;
  readonly description: string;
  readonly schema: any;  // JSON Schema
  readonly execute: (args: TArgs) => Promise<string>;
}

/**
 * Internal tool class that handles execution and formatting
 */
class InternalTool<TArgs = any> implements ToolDefinition<TArgs> {
  name: string;
  description: string;
  schema: any;
  execute: (args: TArgs) => Promise<string>;

  constructor(config: ToolDefinition<TArgs>) {
    this.name = config.name;
    this.description = config.description;
    this.schema = config.schema;
    this.execute = config.execute;
  }

  /**
   * Get the tool definition for MCP
   */
  getDefinition(): Tool {
    return {
      base: {
        name: this.name,
        title: this.name,
      },
      description: this.description,
      inputSchema: typeof this.schema === 'string' 
        ? this.schema 
        : JSON.stringify(this.schema),
      outputSchema: undefined,
      annotations: undefined,
      meta: undefined,
    };
  }

  /**
   * Execute the tool with parsed arguments
   */
  async run(args: any): Promise<ToolResult> {
    try {
      const result = await this.execute(args);
      return textResult(result);
    } catch (error) {
      return errorResult(error instanceof Error ? error.message : String(error));
    }
  }
}

/**
 * Factory function to create a tool
 */
export function createTool<TArgs = any>(
  config: ToolDefinition<TArgs>
): ToolDefinition<TArgs> {
  return new InternalTool(config);
}

// ==============================================================================
// RESULT HELPERS
// ==============================================================================

/**
 * Create a text result in MCP format
 */
export function textResult(text: string): ToolResult {
  const textContent: TextContent = {
    text,
    annotations: undefined,
    meta: undefined,
  };
  
  const contentBlock: ContentBlock = {
    tag: 'text',
    val: textContent,
  };
  
  return {
    content: [contentBlock],
    structuredContent: undefined,
    isError: false,
    meta: undefined,
  };
}

/**
 * Create an error result in MCP format
 */
export function errorResult(message: string): ToolResult {
  const textContent: TextContent = {
    text: message,
    annotations: undefined,
    meta: undefined,
  };
  
  const contentBlock: ContentBlock = {
    tag: 'text',
    val: textContent,
  };
  
  return {
    content: [contentBlock],
    structuredContent: undefined,
    isError: true,
    meta: undefined,
  };
}

// ==============================================================================
// HANDLER CREATION
// ==============================================================================

export interface HandlerConfig {
  tools?: ToolDefinition[];
  serverInfo?: {
    name: string;
    version: string;
    instructions: string;
  };
  authConfig?: ProviderAuthConfig | null;
}

export interface Handler {
  coreCapabilities: {
    handleInitialize(request: InitializeRequest): InitializeResponse;
    handleInitialized(): void;
    handlePing(): void;
    handleShutdown(): void;
    getAuthConfig(): ProviderAuthConfig | undefined;
  };
  toolsCapabilities: {
    handleListTools(request: ListToolsRequest): ListToolsResponse;
    handleCallTool(request: CallToolRequest): Promise<ToolResult>;
  };
}

/**
 * Create a handler that implements the MCP capabilities interfaces
 */
export function createHandler(config: HandlerConfig): Handler {
  const tools = config.tools || [];
  const serverInfo = config.serverInfo || {
    name: 'mcp-server',
    version: '0.1.0',
    instructions: 'MCP Server'
  };
  const authConfig = config.authConfig || null;
  
  // Build a map of tools by name for quick lookup
  const toolMap = new Map<string, InternalTool>();
  for (const tool of tools) {
    if (tool instanceof InternalTool) {
      toolMap.set(tool.name, tool);
    } else {
      const toolInstance = new InternalTool(tool);
      toolMap.set(toolInstance.name, toolInstance);
    }
  }
  
  // Core capabilities handlers
  const coreCapabilities = {
    handleInitialize(_request: InitializeRequest): InitializeResponse {
      const toolsCapability: ToolsCapability = {
        listChanged: undefined,
      };
      
      const capabilities: ServerCapabilities = {
        experimental: undefined,
        logging: undefined,
        completions: undefined,
        prompts: undefined,
        resources: undefined,
        tools: toolsCapability,
      };
      
      const info: ImplementationInfo = {
        name: serverInfo.name,
        version: serverInfo.version,
        title: serverInfo.instructions,
      };
      
      return {
        protocolVersion: 'v20250618' as ProtocolVersion,
        capabilities,
        serverInfo: info,
        instructions: serverInfo.instructions,
        meta: undefined,
      };
    },
    
    handleInitialized(): void {
      // No-op for initialized
    },
    
    handlePing(): void {
      // No-op for ping
    },
    
    handleShutdown(): void {
      // No-op for shutdown
    },
    
    getAuthConfig(): ProviderAuthConfig | undefined {
      return authConfig || undefined;
    }
  };
  
  // Tools capabilities handlers
  const toolsCapabilities = {
    handleListTools(_request: ListToolsRequest): ListToolsResponse {
      const toolDefinitions: Tool[] = Array.from(toolMap.values()).map(tool => 
        tool.getDefinition()
      );
      
      return {
        tools: toolDefinitions,
        nextCursor: undefined,
        meta: undefined,
      };
    },
    
    async handleCallTool(request: CallToolRequest): Promise<ToolResult> {
      const tool = toolMap.get(request.name);
      
      if (!tool) {
        return errorResult(`Unknown tool: ${request.name}`);
      }
      
      try {
        // Parse arguments if they're a string
        const args = request.arguments 
          ? (typeof request.arguments === 'string' 
            ? JSON.parse(request.arguments) 
            : request.arguments)
          : {};
        
        // Execute the tool
        return await tool.run(args);
      } catch (error) {
        return errorResult(`Error executing ${request.name}: ${error instanceof Error ? error.message : String(error)}`);
      }
    }
  };
  
  // Return both capability handlers
  return {
    coreCapabilities,
    toolsCapabilities
  };
}