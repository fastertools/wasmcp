Metadata-Version: 2.4
Name: wasmcp
Version: 0.1.0
Summary: Python SDK for WebAssembly MCP (Model Context Protocol) handlers
Classifier: Development Status :: 3 - Alpha
Classifier: Intended Audience :: Developers
Classifier: License :: OSI Approved :: Apache Software License
Classifier: Programming Language :: Python :: 3
Classifier: Programming Language :: Python :: 3.8
Classifier: Programming Language :: Python :: 3.9
Classifier: Programming Language :: Python :: 3.10
Classifier: Programming Language :: Python :: 3.11
Classifier: Topic :: Software Development :: Libraries :: Python Modules
Classifier: Topic :: System :: Distributed Computing
Requires-Python: >=3.8
Description-Content-Type: text/markdown
Provides-Extra: dev
Requires-Dist: pytest>=7.0.0; extra == "dev"
Requires-Dist: pytest-cov>=4.0.0; extra == "dev"
Requires-Dist: black>=22.0.0; extra == "dev"
Requires-Dist: isort>=5.10.0; extra == "dev"
Requires-Dist: mypy>=1.0.0; extra == "dev"

# wasmcp-python

Python SDK for MCP WebAssembly components (Work in Progress).

⚠️ **Status**: This SDK is under development. The decorator API works for local Python development, but WASM compilation requires additional work to properly generate WIT bindings.

## Current Features

- **Decorator-based API**: Simple `@handler.tool` decorators for defining handlers
- **Type hints**: JSON Schema generation from Python type annotations
- **Local testing**: Full functionality for Python development and testing
- **WIT bundling**: Includes necessary WIT files for componentize-py

## In Development

- **Proper WIT binding generation**: Currently requires manual export mapping
- **WASM async runtime**: Python's asyncio doesn't work in WASM (investigating alternatives)
- **Component validation**: Ensuring generated components properly implement MCP protocol

## Quick Start

### 1. Install the SDK

```bash
# Install from source (package not yet published to PyPI)
cd /path/to/wasmcp/src/sdk/wasmcp-python
pip install -e .
```

### 2. Create Your First Handler

Create a new file `handler.py`:

```python
from wasmcp import WasmcpHandler

# Create handler
handler = WasmcpHandler("my-tools")

# Sync tool
@handler.tool
def echo(message: str) -> str:
    """Echo a message back."""
    return f"Echo: {message}"

# Async tool with HTTP
@handler.tool
async def weather(location: str) -> dict:
    """Get weather for a location."""
    from spin_sdk import http
    
    response = await http.send(
        http.Request("GET", f"https://api.weather.com?q={location}")
    )
    return {"location": location, "data": response.body}

# Build for WASM - no WIT files needed!
handler.build()
```

Or for a more complete example:

```python
from wasmcp import WasmcpHandler
from typing import Optional, List, Dict

handler = WasmcpHandler("calculator")

@handler.tool
def calculate(operation: str, a: float, b: float) -> float:
    """Perform a mathematical calculation.
    
    Args:
        operation: The operation to perform (add, subtract, multiply, divide)
        a: First operand
        b: Second operand
        
    Returns:
        The result of the calculation
    """
    if operation == "add":
        return a + b
    elif operation == "subtract":
        return a - b
    elif operation == "multiply":
        return a * b
    elif operation == "divide":
        if b == 0:
            raise ValueError("Division by zero")
        return a / b
    else:
        raise ValueError(f"Unknown operation: {operation}")

# Register a resource to expose data
@handler.resource(uri="config://calculator", mime_type="application/json")
def get_calculator_config() -> dict:
    """Get calculator configuration and supported operations."""
    return {
        "version": "1.0.0",
        "supported_operations": ["add", "subtract", "multiply", "divide"],
        "precision": 10
    }

# Register a prompt template
@handler.prompt
def math_tutor(topic: str = "arithmetic", difficulty: str = "beginner") -> list:
    """Generate a math tutoring prompt.
    
    Args:
        topic: Math topic to focus on
        difficulty: Difficulty level (beginner, intermediate, advanced)
    """
    return [
        {
            "role": "system", 
            "content": f"You are a helpful {topic} tutor teaching at the {difficulty} level."
        },
        {
            "role": "user", 
            "content": "I need help understanding this math problem."
        }
    ]

# Build and export the handler (required for WASM compilation)
handler.build()
```

### 3. Test Your Handler Locally

Create a test file `test_handler.py`:

```python
import json
from example_handler import handler
from wasmcp.exports import WasmcpExports

# Create exports wrapper
exports = WasmcpExports(handler)

# Test listing tools
tools = exports.list_tools()
print(f"Available tools: {[t['name'] for t in tools]}")

# Test calling a tool
result = exports.call_tool("calculate", json.dumps({
    "operation": "multiply",
    "a": 7,
    "b": 6
}))
print(f"7 * 6 = {result['result']['text']}")

# Test reading a resource
config = exports.read_resource("config://calculator")
config_data = json.loads(config['result']['contents'][0]['text'])
print(f"Calculator version: {config_data['version']}")

# Test getting a prompt
prompt = exports.get_prompt("math_tutor", json.dumps({
    "topic": "algebra",
    "difficulty": "intermediate"
}))
messages = prompt['result']['messages']
print(f"Generated prompt with {len(messages)} messages")
```

Run the test:

```bash
python test_handler.py
```

Expected output:
```
Available tools: ['calculate']
7 * 6 = 42
Calculator version: 1.0.0
Generated prompt with 2 messages
```

### 4. Compile to WebAssembly

**Zero configuration needed!** The SDK bundles all WIT files and handles the complexity for you.

```bash
# Install build dependencies
pip install componentize-py

# Build your handler with one command
wasmcp-build example_handler.py

# That's it! Your handler.wasm is ready
```

#### Build Options

```bash
# Specify output file
wasmcp-build example_handler.py -o my-handler.wasm

# Verbose output for debugging
wasmcp-build example_handler.py --verbose

# Use the Python module directly
python -m wasmcp.build example_handler.py
```

The build system automatically:
- ✅ Bundles all necessary WIT interfaces
- ✅ Configures componentize-py for you
- ✅ Validates your Python handler
- ✅ Produces optimized WASM output
- ✅ Works with async handlers (using Spin runtime)

## Async Support

The Python SDK has full async support, just like the Rust SDK. Both sync and async handlers work seamlessly:

```python
from wasmcp import WasmcpHandler
from spin_sdk import http, key_value

handler = WasmcpHandler("async-example")

# Async tool with HTTP request
@handler.tool
async def fetch_data(url: str) -> str:
    """Fetch data from a URL."""
    response = await http.send(
        http.Request("GET", url)
    )
    return response.body

# Async tool with KV store
@handler.tool  
async def cache_result(key: str, value: str) -> None:
    """Cache a result in KV store."""
    store = key_value.open("default")
    store.set(key, value.encode())
    
# Sync and async tools can coexist
@handler.tool
def process_sync(data: str) -> str:
    """Process data synchronously."""
    return data.upper()

handler.build()
```

## Complete Example: Weather Service

Here's a complete example showing all features:

```python
from wasmcp import WasmcpHandler
from typing import Optional, Dict, List
from datetime import datetime

handler = WasmcpHandler("weather-assistant")

# In-memory storage for demo purposes
weather_data = {
    "New York": {"temp": 72, "condition": "sunny"},
    "London": {"temp": 59, "condition": "cloudy"},
    "Tokyo": {"temp": 68, "condition": "partly cloudy"}
}

@handler.tool(name="get_weather")
def get_weather(city: str, units: str = "fahrenheit") -> Dict[str, any]:
    """Get current weather for a city.
    
    Args:
        city: Name of the city
        units: Temperature units (fahrenheit or celsius)
        
    Returns:
        Weather information including temperature and conditions
    """
    if city not in weather_data:
        raise ValueError(f"Weather data not available for {city}")
    
    data = weather_data[city].copy()
    
    # Convert temperature if needed
    if units == "celsius":
        data["temp"] = round((data["temp"] - 32) * 5/9, 1)
        data["units"] = "celsius"
    else:
        data["units"] = "fahrenheit"
    
    data["city"] = city
    data["timestamp"] = datetime.now().isoformat()
    
    return data

@handler.tool
def list_available_cities() -> List[str]:
    """Get list of cities with available weather data."""
    return list(weather_data.keys())

@handler.resource(uri="weather://current/all", mime_type="application/json")
def get_all_weather() -> dict:
    """Get current weather for all available cities."""
    return {
        "cities": weather_data,
        "last_updated": datetime.now().isoformat()
    }

@handler.prompt(name="weather_report")
def weather_report_prompt(city: Optional[str] = None) -> list:
    """Generate a weather report prompt.
    
    Args:
        city: Optional city to focus the report on
    """
    messages = [
        {
            "role": "system",
            "content": "You are a friendly weather reporter. Provide clear, concise weather information."
        }
    ]
    
    if city:
        messages.append({
            "role": "user",
            "content": f"What's the weather like in {city} today?"
        })
    else:
        messages.append({
            "role": "user", 
            "content": "Give me a weather summary for all major cities."
        })
    
    return messages

# Build the handler
handler.build()
```

## API Reference

### Handler Creation

```python
handler = WasmcpHandler(name="my-handler", version="1.0.0", description="My MCP handler")
```

### Tool Registration

```python
@handler.tool(name="custom_name", description="Tool description")
def my_tool(param1: str, param2: int = 0) -> dict:
    """Tool implementation."""
    return {"result": param1, "count": param2}
```

### Resource Registration

```python
@handler.resource(
    uri="protocol://path",
    name="Resource Name",
    description="Resource description",
    mime_type="application/json"
)
def my_resource() -> dict:
    """Resource implementation."""
    return {"data": "value"}
```

### Prompt Registration

```python
@handler.prompt(name="prompt_name", description="Prompt description")
def my_prompt(variable: str = "default") -> list:
    """Prompt implementation."""
    return [
        {"role": "system", "content": "System message"},
        {"role": "user", "content": f"User message with {variable}"}
    ]
```

## Testing

Run the test suite:

```bash
# Run all tests
pytest tests/ -v

# Run with coverage
pytest tests/ --cov=wasmcp --cov-report=term-missing

# Run specific test file
pytest tests/test_handler.py -v
```

## Development

```bash
# Install in development mode with test dependencies
pip install -e ".[dev]"

# Run tests
pytest

# Format code
black src/ tests/

# Type checking (if using mypy)
mypy src/
```

## SDK Comparison

All wasmcp SDKs provide the same zero-configuration experience:

| Feature | Python | Rust | TypeScript |
|---------|---------|------|------------|
| Zero WIT files | ✅ Bundled | ✅ Proc macro | ✅ Bundled |
| Async support | ✅ Native async/await | ✅ Native async/await | ✅ Native async/await |
| Build command | `wasmcp-build` | `cargo component build` | `npm run build` |
| Type safety | Type hints → JSON Schema | Rust types → JSON Schema | Zod → JSON Schema |
| HTTP client | `spin_sdk.http` | `spin_sdk::http` | `fetch` API |
| KV store | `spin_sdk.key_value` | `spin_sdk::key_value` | `@fermyon/spin-sdk` |

## Why wasmcp?

- **No WIT file management**: Unlike raw componentize-py, you never touch WIT files
- **Unified API**: Same patterns across Python, Rust, and TypeScript
- **Production ready**: Built on Spin's runtime for real-world WASI capabilities
- **Type safe**: Automatic JSON Schema generation from Python types
- **Async first**: Modern async/await support throughout

## License

Apache-2.0
