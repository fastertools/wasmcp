// Generated by `wit-bindgen` 0.41.0. DO NOT EDIT!
// Options used:
//   * runtime_path: "wit_bindgen_rt"
#[rustfmt::skip]
#[allow(dead_code, clippy::all)]
pub mod wasmcp {
    pub mod mcp {
        #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
        pub mod types {
            #[used]
            #[doc(hidden)]
            static __FORCE_SECTION_REF: fn() = super::super::super::__link_custom_section_describing_imports;
            use super::super::super::_rt;
            /// Tool descriptor
            #[derive(Clone)]
            pub struct Tool {
                pub name: _rt::String,
                pub description: _rt::String,
                pub input_schema: _rt::String,
            }
            impl ::core::fmt::Debug for Tool {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("Tool")
                        .field("name", &self.name)
                        .field("description", &self.description)
                        .field("input-schema", &self.input_schema)
                        .finish()
                }
            }
            /// Error type
            #[derive(Clone)]
            pub struct Error {
                pub code: i32,
                pub message: _rt::String,
                pub data: Option<_rt::String>,
            }
            impl ::core::fmt::Debug for Error {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("Error")
                        .field("code", &self.code)
                        .field("message", &self.message)
                        .field("data", &self.data)
                        .finish()
                }
            }
            /// Tool execution result
            #[derive(Clone)]
            pub enum ToolResult {
                Text(_rt::String),
                Error(Error),
            }
            impl ::core::fmt::Debug for ToolResult {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    match self {
                        ToolResult::Text(e) => {
                            f.debug_tuple("ToolResult::Text").field(e).finish()
                        }
                        ToolResult::Error(e) => {
                            f.debug_tuple("ToolResult::Error").field(e).finish()
                        }
                    }
                }
            }
            /// Resource descriptor
            #[derive(Clone)]
            pub struct ResourceInfo {
                pub uri: _rt::String,
                pub name: _rt::String,
                pub description: Option<_rt::String>,
                pub mime_type: Option<_rt::String>,
            }
            impl ::core::fmt::Debug for ResourceInfo {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("ResourceInfo")
                        .field("uri", &self.uri)
                        .field("name", &self.name)
                        .field("description", &self.description)
                        .field("mime-type", &self.mime_type)
                        .finish()
                }
            }
            /// Resource contents
            #[derive(Clone)]
            pub struct ResourceContents {
                pub uri: _rt::String,
                pub mime_type: Option<_rt::String>,
                pub text: Option<_rt::String>,
                pub blob: Option<_rt::Vec<u8>>,
            }
            impl ::core::fmt::Debug for ResourceContents {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("ResourceContents")
                        .field("uri", &self.uri)
                        .field("mime-type", &self.mime_type)
                        .field("text", &self.text)
                        .field("blob", &self.blob)
                        .finish()
                }
            }
            /// Resource read result
            #[derive(Clone)]
            pub enum ResourceResult {
                Contents(ResourceContents),
                Error(Error),
            }
            impl ::core::fmt::Debug for ResourceResult {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    match self {
                        ResourceResult::Contents(e) => {
                            f.debug_tuple("ResourceResult::Contents").field(e).finish()
                        }
                        ResourceResult::Error(e) => {
                            f.debug_tuple("ResourceResult::Error").field(e).finish()
                        }
                    }
                }
            }
            /// Prompt argument
            #[derive(Clone)]
            pub struct PromptArgument {
                pub name: _rt::String,
                pub description: Option<_rt::String>,
                pub required: bool,
            }
            impl ::core::fmt::Debug for PromptArgument {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("PromptArgument")
                        .field("name", &self.name)
                        .field("description", &self.description)
                        .field("required", &self.required)
                        .finish()
                }
            }
            /// Prompt descriptor
            #[derive(Clone)]
            pub struct PromptDescriptor {
                pub name: _rt::String,
                pub description: Option<_rt::String>,
                pub arguments: _rt::Vec<PromptArgument>,
            }
            impl ::core::fmt::Debug for PromptDescriptor {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("PromptDescriptor")
                        .field("name", &self.name)
                        .field("description", &self.description)
                        .field("arguments", &self.arguments)
                        .finish()
                }
            }
            /// Prompt message
            #[derive(Clone)]
            pub struct PromptMessage {
                pub role: _rt::String,
                pub content: _rt::String,
            }
            impl ::core::fmt::Debug for PromptMessage {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("PromptMessage")
                        .field("role", &self.role)
                        .field("content", &self.content)
                        .finish()
                }
            }
            /// Prompt execution result
            #[derive(Clone)]
            pub enum PromptResult {
                Messages(_rt::Vec<PromptMessage>),
                Error(Error),
            }
            impl ::core::fmt::Debug for PromptResult {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    match self {
                        PromptResult::Messages(e) => {
                            f.debug_tuple("PromptResult::Messages").field(e).finish()
                        }
                        PromptResult::Error(e) => {
                            f.debug_tuple("PromptResult::Error").field(e).finish()
                        }
                    }
                }
            }
        }
        #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
        pub mod handler {
            #[used]
            #[doc(hidden)]
            static __FORCE_SECTION_REF: fn() = super::super::super::__link_custom_section_describing_imports;
            use super::super::super::_rt;
            pub type Tool = super::super::super::wasmcp::mcp::types::Tool;
            pub type ToolResult = super::super::super::wasmcp::mcp::types::ToolResult;
            pub type ResourceInfo = super::super::super::wasmcp::mcp::types::ResourceInfo;
            pub type ResourceResult = super::super::super::wasmcp::mcp::types::ResourceResult;
            pub type PromptDescriptor = super::super::super::wasmcp::mcp::types::PromptDescriptor;
            pub type PromptResult = super::super::super::wasmcp::mcp::types::PromptResult;
            #[allow(unused_unsafe, clippy::all)]
            /// List available tools - synchronous as it's just metadata
            pub fn list_tools() -> _rt::Vec<Tool> {
                unsafe {
                    #[cfg_attr(target_pointer_width = "64", repr(align(8)))]
                    #[cfg_attr(target_pointer_width = "32", repr(align(4)))]
                    struct RetArea(
                        [::core::mem::MaybeUninit<
                            u8,
                        >; 2 * ::core::mem::size_of::<*const u8>()],
                    );
                    let mut ret_area = RetArea(
                        [::core::mem::MaybeUninit::uninit(); 2
                            * ::core::mem::size_of::<*const u8>()],
                    );
                    let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "wasmcp:mcp/handler@0.1.0")]
                    unsafe extern "C" {
                        #[link_name = "list-tools"]
                        fn wit_import1(_: *mut u8);
                    }
                    #[cfg(not(target_arch = "wasm32"))]
                    unsafe extern "C" fn wit_import1(_: *mut u8) {
                        unreachable!()
                    }
                    unsafe { wit_import1(ptr0) };
                    let l2 = *ptr0.add(0).cast::<*mut u8>();
                    let l3 = *ptr0
                        .add(::core::mem::size_of::<*const u8>())
                        .cast::<usize>();
                    let base13 = l2;
                    let len13 = l3;
                    let mut result13 = _rt::Vec::with_capacity(len13);
                    for i in 0..len13 {
                        let base = base13
                            .add(i * (6 * ::core::mem::size_of::<*const u8>()));
                        let e13 = {
                            let l4 = *base.add(0).cast::<*mut u8>();
                            let l5 = *base
                                .add(::core::mem::size_of::<*const u8>())
                                .cast::<usize>();
                            let len6 = l5;
                            let bytes6 = _rt::Vec::from_raw_parts(l4.cast(), len6, len6);
                            let l7 = *base
                                .add(2 * ::core::mem::size_of::<*const u8>())
                                .cast::<*mut u8>();
                            let l8 = *base
                                .add(3 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>();
                            let len9 = l8;
                            let bytes9 = _rt::Vec::from_raw_parts(l7.cast(), len9, len9);
                            let l10 = *base
                                .add(4 * ::core::mem::size_of::<*const u8>())
                                .cast::<*mut u8>();
                            let l11 = *base
                                .add(5 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>();
                            let len12 = l11;
                            let bytes12 = _rt::Vec::from_raw_parts(
                                l10.cast(),
                                len12,
                                len12,
                            );
                            super::super::super::wasmcp::mcp::types::Tool {
                                name: _rt::string_lift(bytes6),
                                description: _rt::string_lift(bytes9),
                                input_schema: _rt::string_lift(bytes12),
                            }
                        };
                        result13.push(e13);
                    }
                    _rt::cabi_dealloc(
                        base13,
                        len13 * (6 * ::core::mem::size_of::<*const u8>()),
                        ::core::mem::size_of::<*const u8>(),
                    );
                    let result14 = result13;
                    result14
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            /// Call a tool - synchronous (ComponentizeJS will handle async-to-sync conversion)
            pub fn call_tool(name: &str, arguments: &str) -> ToolResult {
                unsafe {
                    #[cfg_attr(target_pointer_width = "64", repr(align(8)))]
                    #[cfg_attr(target_pointer_width = "32", repr(align(4)))]
                    struct RetArea(
                        [::core::mem::MaybeUninit<
                            u8,
                        >; 7 * ::core::mem::size_of::<*const u8>()],
                    );
                    let mut ret_area = RetArea(
                        [::core::mem::MaybeUninit::uninit(); 7
                            * ::core::mem::size_of::<*const u8>()],
                    );
                    let vec0 = name;
                    let ptr0 = vec0.as_ptr().cast::<u8>();
                    let len0 = vec0.len();
                    let vec1 = arguments;
                    let ptr1 = vec1.as_ptr().cast::<u8>();
                    let len1 = vec1.len();
                    let ptr2 = ret_area.0.as_mut_ptr().cast::<u8>();
                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "wasmcp:mcp/handler@0.1.0")]
                    unsafe extern "C" {
                        #[link_name = "call-tool"]
                        fn wit_import3(
                            _: *mut u8,
                            _: usize,
                            _: *mut u8,
                            _: usize,
                            _: *mut u8,
                        );
                    }
                    #[cfg(not(target_arch = "wasm32"))]
                    unsafe extern "C" fn wit_import3(
                        _: *mut u8,
                        _: usize,
                        _: *mut u8,
                        _: usize,
                        _: *mut u8,
                    ) {
                        unreachable!()
                    }
                    unsafe {
                        wit_import3(ptr0.cast_mut(), len0, ptr1.cast_mut(), len1, ptr2)
                    };
                    let l4 = i32::from(*ptr2.add(0).cast::<u8>());
                    use super::super::super::wasmcp::mcp::types::ToolResult as V16;
                    let v16 = match l4 {
                        0 => {
                            let e16 = {
                                let l5 = *ptr2
                                    .add(::core::mem::size_of::<*const u8>())
                                    .cast::<*mut u8>();
                                let l6 = *ptr2
                                    .add(2 * ::core::mem::size_of::<*const u8>())
                                    .cast::<usize>();
                                let len7 = l6;
                                let bytes7 = _rt::Vec::from_raw_parts(
                                    l5.cast(),
                                    len7,
                                    len7,
                                );
                                _rt::string_lift(bytes7)
                            };
                            V16::Text(e16)
                        }
                        n => {
                            debug_assert_eq!(n, 1, "invalid enum discriminant");
                            let e16 = {
                                let l8 = *ptr2
                                    .add(::core::mem::size_of::<*const u8>())
                                    .cast::<i32>();
                                let l9 = *ptr2
                                    .add(2 * ::core::mem::size_of::<*const u8>())
                                    .cast::<*mut u8>();
                                let l10 = *ptr2
                                    .add(3 * ::core::mem::size_of::<*const u8>())
                                    .cast::<usize>();
                                let len11 = l10;
                                let bytes11 = _rt::Vec::from_raw_parts(
                                    l9.cast(),
                                    len11,
                                    len11,
                                );
                                let l12 = i32::from(
                                    *ptr2
                                        .add(4 * ::core::mem::size_of::<*const u8>())
                                        .cast::<u8>(),
                                );
                                super::super::super::wasmcp::mcp::types::Error {
                                    code: l8,
                                    message: _rt::string_lift(bytes11),
                                    data: match l12 {
                                        0 => None,
                                        1 => {
                                            let e = {
                                                let l13 = *ptr2
                                                    .add(5 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<*mut u8>();
                                                let l14 = *ptr2
                                                    .add(6 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<usize>();
                                                let len15 = l14;
                                                let bytes15 = _rt::Vec::from_raw_parts(
                                                    l13.cast(),
                                                    len15,
                                                    len15,
                                                );
                                                _rt::string_lift(bytes15)
                                            };
                                            Some(e)
                                        }
                                        _ => _rt::invalid_enum_discriminant(),
                                    },
                                }
                            };
                            V16::Error(e16)
                        }
                    };
                    let result17 = v16;
                    result17
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            /// List available resources - synchronous
            pub fn list_resources() -> _rt::Vec<ResourceInfo> {
                unsafe {
                    #[cfg_attr(target_pointer_width = "64", repr(align(8)))]
                    #[cfg_attr(target_pointer_width = "32", repr(align(4)))]
                    struct RetArea(
                        [::core::mem::MaybeUninit<
                            u8,
                        >; 2 * ::core::mem::size_of::<*const u8>()],
                    );
                    let mut ret_area = RetArea(
                        [::core::mem::MaybeUninit::uninit(); 2
                            * ::core::mem::size_of::<*const u8>()],
                    );
                    let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "wasmcp:mcp/handler@0.1.0")]
                    unsafe extern "C" {
                        #[link_name = "list-resources"]
                        fn wit_import1(_: *mut u8);
                    }
                    #[cfg(not(target_arch = "wasm32"))]
                    unsafe extern "C" fn wit_import1(_: *mut u8) {
                        unreachable!()
                    }
                    unsafe { wit_import1(ptr0) };
                    let l2 = *ptr0.add(0).cast::<*mut u8>();
                    let l3 = *ptr0
                        .add(::core::mem::size_of::<*const u8>())
                        .cast::<usize>();
                    let base18 = l2;
                    let len18 = l3;
                    let mut result18 = _rt::Vec::with_capacity(len18);
                    for i in 0..len18 {
                        let base = base18
                            .add(i * (10 * ::core::mem::size_of::<*const u8>()));
                        let e18 = {
                            let l4 = *base.add(0).cast::<*mut u8>();
                            let l5 = *base
                                .add(::core::mem::size_of::<*const u8>())
                                .cast::<usize>();
                            let len6 = l5;
                            let bytes6 = _rt::Vec::from_raw_parts(l4.cast(), len6, len6);
                            let l7 = *base
                                .add(2 * ::core::mem::size_of::<*const u8>())
                                .cast::<*mut u8>();
                            let l8 = *base
                                .add(3 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>();
                            let len9 = l8;
                            let bytes9 = _rt::Vec::from_raw_parts(l7.cast(), len9, len9);
                            let l10 = i32::from(
                                *base
                                    .add(4 * ::core::mem::size_of::<*const u8>())
                                    .cast::<u8>(),
                            );
                            let l14 = i32::from(
                                *base
                                    .add(7 * ::core::mem::size_of::<*const u8>())
                                    .cast::<u8>(),
                            );
                            super::super::super::wasmcp::mcp::types::ResourceInfo {
                                uri: _rt::string_lift(bytes6),
                                name: _rt::string_lift(bytes9),
                                description: match l10 {
                                    0 => None,
                                    1 => {
                                        let e = {
                                            let l11 = *base
                                                .add(5 * ::core::mem::size_of::<*const u8>())
                                                .cast::<*mut u8>();
                                            let l12 = *base
                                                .add(6 * ::core::mem::size_of::<*const u8>())
                                                .cast::<usize>();
                                            let len13 = l12;
                                            let bytes13 = _rt::Vec::from_raw_parts(
                                                l11.cast(),
                                                len13,
                                                len13,
                                            );
                                            _rt::string_lift(bytes13)
                                        };
                                        Some(e)
                                    }
                                    _ => _rt::invalid_enum_discriminant(),
                                },
                                mime_type: match l14 {
                                    0 => None,
                                    1 => {
                                        let e = {
                                            let l15 = *base
                                                .add(8 * ::core::mem::size_of::<*const u8>())
                                                .cast::<*mut u8>();
                                            let l16 = *base
                                                .add(9 * ::core::mem::size_of::<*const u8>())
                                                .cast::<usize>();
                                            let len17 = l16;
                                            let bytes17 = _rt::Vec::from_raw_parts(
                                                l15.cast(),
                                                len17,
                                                len17,
                                            );
                                            _rt::string_lift(bytes17)
                                        };
                                        Some(e)
                                    }
                                    _ => _rt::invalid_enum_discriminant(),
                                },
                            }
                        };
                        result18.push(e18);
                    }
                    _rt::cabi_dealloc(
                        base18,
                        len18 * (10 * ::core::mem::size_of::<*const u8>()),
                        ::core::mem::size_of::<*const u8>(),
                    );
                    let result19 = result18;
                    result19
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            /// Read a resource - synchronous (ComponentizeJS will handle async-to-sync conversion)
            pub fn read_resource(uri: &str) -> ResourceResult {
                unsafe {
                    #[cfg_attr(target_pointer_width = "64", repr(align(8)))]
                    #[cfg_attr(target_pointer_width = "32", repr(align(4)))]
                    struct RetArea(
                        [::core::mem::MaybeUninit<
                            u8,
                        >; 12 * ::core::mem::size_of::<*const u8>()],
                    );
                    let mut ret_area = RetArea(
                        [::core::mem::MaybeUninit::uninit(); 12
                            * ::core::mem::size_of::<*const u8>()],
                    );
                    let vec0 = uri;
                    let ptr0 = vec0.as_ptr().cast::<u8>();
                    let len0 = vec0.len();
                    let ptr1 = ret_area.0.as_mut_ptr().cast::<u8>();
                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "wasmcp:mcp/handler@0.1.0")]
                    unsafe extern "C" {
                        #[link_name = "read-resource"]
                        fn wit_import2(_: *mut u8, _: usize, _: *mut u8);
                    }
                    #[cfg(not(target_arch = "wasm32"))]
                    unsafe extern "C" fn wit_import2(_: *mut u8, _: usize, _: *mut u8) {
                        unreachable!()
                    }
                    unsafe { wit_import2(ptr0.cast_mut(), len0, ptr1) };
                    let l3 = i32::from(*ptr1.add(0).cast::<u8>());
                    use super::super::super::wasmcp::mcp::types::ResourceResult as V27;
                    let v27 = match l3 {
                        0 => {
                            let e27 = {
                                let l4 = *ptr1
                                    .add(::core::mem::size_of::<*const u8>())
                                    .cast::<*mut u8>();
                                let l5 = *ptr1
                                    .add(2 * ::core::mem::size_of::<*const u8>())
                                    .cast::<usize>();
                                let len6 = l5;
                                let bytes6 = _rt::Vec::from_raw_parts(
                                    l4.cast(),
                                    len6,
                                    len6,
                                );
                                let l7 = i32::from(
                                    *ptr1
                                        .add(3 * ::core::mem::size_of::<*const u8>())
                                        .cast::<u8>(),
                                );
                                let l11 = i32::from(
                                    *ptr1
                                        .add(6 * ::core::mem::size_of::<*const u8>())
                                        .cast::<u8>(),
                                );
                                let l15 = i32::from(
                                    *ptr1
                                        .add(9 * ::core::mem::size_of::<*const u8>())
                                        .cast::<u8>(),
                                );
                                super::super::super::wasmcp::mcp::types::ResourceContents {
                                    uri: _rt::string_lift(bytes6),
                                    mime_type: match l7 {
                                        0 => None,
                                        1 => {
                                            let e = {
                                                let l8 = *ptr1
                                                    .add(4 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<*mut u8>();
                                                let l9 = *ptr1
                                                    .add(5 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<usize>();
                                                let len10 = l9;
                                                let bytes10 = _rt::Vec::from_raw_parts(
                                                    l8.cast(),
                                                    len10,
                                                    len10,
                                                );
                                                _rt::string_lift(bytes10)
                                            };
                                            Some(e)
                                        }
                                        _ => _rt::invalid_enum_discriminant(),
                                    },
                                    text: match l11 {
                                        0 => None,
                                        1 => {
                                            let e = {
                                                let l12 = *ptr1
                                                    .add(7 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<*mut u8>();
                                                let l13 = *ptr1
                                                    .add(8 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<usize>();
                                                let len14 = l13;
                                                let bytes14 = _rt::Vec::from_raw_parts(
                                                    l12.cast(),
                                                    len14,
                                                    len14,
                                                );
                                                _rt::string_lift(bytes14)
                                            };
                                            Some(e)
                                        }
                                        _ => _rt::invalid_enum_discriminant(),
                                    },
                                    blob: match l15 {
                                        0 => None,
                                        1 => {
                                            let e = {
                                                let l16 = *ptr1
                                                    .add(10 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<*mut u8>();
                                                let l17 = *ptr1
                                                    .add(11 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<usize>();
                                                let len18 = l17;
                                                _rt::Vec::from_raw_parts(l16.cast(), len18, len18)
                                            };
                                            Some(e)
                                        }
                                        _ => _rt::invalid_enum_discriminant(),
                                    },
                                }
                            };
                            V27::Contents(e27)
                        }
                        n => {
                            debug_assert_eq!(n, 1, "invalid enum discriminant");
                            let e27 = {
                                let l19 = *ptr1
                                    .add(::core::mem::size_of::<*const u8>())
                                    .cast::<i32>();
                                let l20 = *ptr1
                                    .add(2 * ::core::mem::size_of::<*const u8>())
                                    .cast::<*mut u8>();
                                let l21 = *ptr1
                                    .add(3 * ::core::mem::size_of::<*const u8>())
                                    .cast::<usize>();
                                let len22 = l21;
                                let bytes22 = _rt::Vec::from_raw_parts(
                                    l20.cast(),
                                    len22,
                                    len22,
                                );
                                let l23 = i32::from(
                                    *ptr1
                                        .add(4 * ::core::mem::size_of::<*const u8>())
                                        .cast::<u8>(),
                                );
                                super::super::super::wasmcp::mcp::types::Error {
                                    code: l19,
                                    message: _rt::string_lift(bytes22),
                                    data: match l23 {
                                        0 => None,
                                        1 => {
                                            let e = {
                                                let l24 = *ptr1
                                                    .add(5 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<*mut u8>();
                                                let l25 = *ptr1
                                                    .add(6 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<usize>();
                                                let len26 = l25;
                                                let bytes26 = _rt::Vec::from_raw_parts(
                                                    l24.cast(),
                                                    len26,
                                                    len26,
                                                );
                                                _rt::string_lift(bytes26)
                                            };
                                            Some(e)
                                        }
                                        _ => _rt::invalid_enum_discriminant(),
                                    },
                                }
                            };
                            V27::Error(e27)
                        }
                    };
                    let result28 = v27;
                    result28
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            /// List available prompts - synchronous
            pub fn list_prompts() -> _rt::Vec<PromptDescriptor> {
                unsafe {
                    #[cfg_attr(target_pointer_width = "64", repr(align(8)))]
                    #[cfg_attr(target_pointer_width = "32", repr(align(4)))]
                    struct RetArea(
                        [::core::mem::MaybeUninit<
                            u8,
                        >; 2 * ::core::mem::size_of::<*const u8>()],
                    );
                    let mut ret_area = RetArea(
                        [::core::mem::MaybeUninit::uninit(); 2
                            * ::core::mem::size_of::<*const u8>()],
                    );
                    let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "wasmcp:mcp/handler@0.1.0")]
                    unsafe extern "C" {
                        #[link_name = "list-prompts"]
                        fn wit_import1(_: *mut u8);
                    }
                    #[cfg(not(target_arch = "wasm32"))]
                    unsafe extern "C" fn wit_import1(_: *mut u8) {
                        unreachable!()
                    }
                    unsafe { wit_import1(ptr0) };
                    let l2 = *ptr0.add(0).cast::<*mut u8>();
                    let l3 = *ptr0
                        .add(::core::mem::size_of::<*const u8>())
                        .cast::<usize>();
                    let base22 = l2;
                    let len22 = l3;
                    let mut result22 = _rt::Vec::with_capacity(len22);
                    for i in 0..len22 {
                        let base = base22
                            .add(i * (7 * ::core::mem::size_of::<*const u8>()));
                        let e22 = {
                            let l4 = *base.add(0).cast::<*mut u8>();
                            let l5 = *base
                                .add(::core::mem::size_of::<*const u8>())
                                .cast::<usize>();
                            let len6 = l5;
                            let bytes6 = _rt::Vec::from_raw_parts(l4.cast(), len6, len6);
                            let l7 = i32::from(
                                *base
                                    .add(2 * ::core::mem::size_of::<*const u8>())
                                    .cast::<u8>(),
                            );
                            let l11 = *base
                                .add(5 * ::core::mem::size_of::<*const u8>())
                                .cast::<*mut u8>();
                            let l12 = *base
                                .add(6 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>();
                            let base21 = l11;
                            let len21 = l12;
                            let mut result21 = _rt::Vec::with_capacity(len21);
                            for i in 0..len21 {
                                let base = base21
                                    .add(i * (6 * ::core::mem::size_of::<*const u8>()));
                                let e21 = {
                                    let l13 = *base.add(0).cast::<*mut u8>();
                                    let l14 = *base
                                        .add(::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    let len15 = l14;
                                    let bytes15 = _rt::Vec::from_raw_parts(
                                        l13.cast(),
                                        len15,
                                        len15,
                                    );
                                    let l16 = i32::from(
                                        *base
                                            .add(2 * ::core::mem::size_of::<*const u8>())
                                            .cast::<u8>(),
                                    );
                                    let l20 = i32::from(
                                        *base
                                            .add(5 * ::core::mem::size_of::<*const u8>())
                                            .cast::<u8>(),
                                    );
                                    super::super::super::wasmcp::mcp::types::PromptArgument {
                                        name: _rt::string_lift(bytes15),
                                        description: match l16 {
                                            0 => None,
                                            1 => {
                                                let e = {
                                                    let l17 = *base
                                                        .add(3 * ::core::mem::size_of::<*const u8>())
                                                        .cast::<*mut u8>();
                                                    let l18 = *base
                                                        .add(4 * ::core::mem::size_of::<*const u8>())
                                                        .cast::<usize>();
                                                    let len19 = l18;
                                                    let bytes19 = _rt::Vec::from_raw_parts(
                                                        l17.cast(),
                                                        len19,
                                                        len19,
                                                    );
                                                    _rt::string_lift(bytes19)
                                                };
                                                Some(e)
                                            }
                                            _ => _rt::invalid_enum_discriminant(),
                                        },
                                        required: _rt::bool_lift(l20 as u8),
                                    }
                                };
                                result21.push(e21);
                            }
                            _rt::cabi_dealloc(
                                base21,
                                len21 * (6 * ::core::mem::size_of::<*const u8>()),
                                ::core::mem::size_of::<*const u8>(),
                            );
                            super::super::super::wasmcp::mcp::types::PromptDescriptor {
                                name: _rt::string_lift(bytes6),
                                description: match l7 {
                                    0 => None,
                                    1 => {
                                        let e = {
                                            let l8 = *base
                                                .add(3 * ::core::mem::size_of::<*const u8>())
                                                .cast::<*mut u8>();
                                            let l9 = *base
                                                .add(4 * ::core::mem::size_of::<*const u8>())
                                                .cast::<usize>();
                                            let len10 = l9;
                                            let bytes10 = _rt::Vec::from_raw_parts(
                                                l8.cast(),
                                                len10,
                                                len10,
                                            );
                                            _rt::string_lift(bytes10)
                                        };
                                        Some(e)
                                    }
                                    _ => _rt::invalid_enum_discriminant(),
                                },
                                arguments: result21,
                            }
                        };
                        result22.push(e22);
                    }
                    _rt::cabi_dealloc(
                        base22,
                        len22 * (7 * ::core::mem::size_of::<*const u8>()),
                        ::core::mem::size_of::<*const u8>(),
                    );
                    let result23 = result22;
                    result23
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            /// Get a prompt - synchronous (ComponentizeJS will handle async-to-sync conversion)
            pub fn get_prompt(name: &str, arguments: &str) -> PromptResult {
                unsafe {
                    #[cfg_attr(target_pointer_width = "64", repr(align(8)))]
                    #[cfg_attr(target_pointer_width = "32", repr(align(4)))]
                    struct RetArea(
                        [::core::mem::MaybeUninit<
                            u8,
                        >; 7 * ::core::mem::size_of::<*const u8>()],
                    );
                    let mut ret_area = RetArea(
                        [::core::mem::MaybeUninit::uninit(); 7
                            * ::core::mem::size_of::<*const u8>()],
                    );
                    let vec0 = name;
                    let ptr0 = vec0.as_ptr().cast::<u8>();
                    let len0 = vec0.len();
                    let vec1 = arguments;
                    let ptr1 = vec1.as_ptr().cast::<u8>();
                    let len1 = vec1.len();
                    let ptr2 = ret_area.0.as_mut_ptr().cast::<u8>();
                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "wasmcp:mcp/handler@0.1.0")]
                    unsafe extern "C" {
                        #[link_name = "get-prompt"]
                        fn wit_import3(
                            _: *mut u8,
                            _: usize,
                            _: *mut u8,
                            _: usize,
                            _: *mut u8,
                        );
                    }
                    #[cfg(not(target_arch = "wasm32"))]
                    unsafe extern "C" fn wit_import3(
                        _: *mut u8,
                        _: usize,
                        _: *mut u8,
                        _: usize,
                        _: *mut u8,
                    ) {
                        unreachable!()
                    }
                    unsafe {
                        wit_import3(ptr0.cast_mut(), len0, ptr1.cast_mut(), len1, ptr2)
                    };
                    let l4 = i32::from(*ptr2.add(0).cast::<u8>());
                    use super::super::super::wasmcp::mcp::types::PromptResult as V22;
                    let v22 = match l4 {
                        0 => {
                            let e22 = {
                                let l5 = *ptr2
                                    .add(::core::mem::size_of::<*const u8>())
                                    .cast::<*mut u8>();
                                let l6 = *ptr2
                                    .add(2 * ::core::mem::size_of::<*const u8>())
                                    .cast::<usize>();
                                let base13 = l5;
                                let len13 = l6;
                                let mut result13 = _rt::Vec::with_capacity(len13);
                                for i in 0..len13 {
                                    let base = base13
                                        .add(i * (4 * ::core::mem::size_of::<*const u8>()));
                                    let e13 = {
                                        let l7 = *base.add(0).cast::<*mut u8>();
                                        let l8 = *base
                                            .add(::core::mem::size_of::<*const u8>())
                                            .cast::<usize>();
                                        let len9 = l8;
                                        let bytes9 = _rt::Vec::from_raw_parts(
                                            l7.cast(),
                                            len9,
                                            len9,
                                        );
                                        let l10 = *base
                                            .add(2 * ::core::mem::size_of::<*const u8>())
                                            .cast::<*mut u8>();
                                        let l11 = *base
                                            .add(3 * ::core::mem::size_of::<*const u8>())
                                            .cast::<usize>();
                                        let len12 = l11;
                                        let bytes12 = _rt::Vec::from_raw_parts(
                                            l10.cast(),
                                            len12,
                                            len12,
                                        );
                                        super::super::super::wasmcp::mcp::types::PromptMessage {
                                            role: _rt::string_lift(bytes9),
                                            content: _rt::string_lift(bytes12),
                                        }
                                    };
                                    result13.push(e13);
                                }
                                _rt::cabi_dealloc(
                                    base13,
                                    len13 * (4 * ::core::mem::size_of::<*const u8>()),
                                    ::core::mem::size_of::<*const u8>(),
                                );
                                result13
                            };
                            V22::Messages(e22)
                        }
                        n => {
                            debug_assert_eq!(n, 1, "invalid enum discriminant");
                            let e22 = {
                                let l14 = *ptr2
                                    .add(::core::mem::size_of::<*const u8>())
                                    .cast::<i32>();
                                let l15 = *ptr2
                                    .add(2 * ::core::mem::size_of::<*const u8>())
                                    .cast::<*mut u8>();
                                let l16 = *ptr2
                                    .add(3 * ::core::mem::size_of::<*const u8>())
                                    .cast::<usize>();
                                let len17 = l16;
                                let bytes17 = _rt::Vec::from_raw_parts(
                                    l15.cast(),
                                    len17,
                                    len17,
                                );
                                let l18 = i32::from(
                                    *ptr2
                                        .add(4 * ::core::mem::size_of::<*const u8>())
                                        .cast::<u8>(),
                                );
                                super::super::super::wasmcp::mcp::types::Error {
                                    code: l14,
                                    message: _rt::string_lift(bytes17),
                                    data: match l18 {
                                        0 => None,
                                        1 => {
                                            let e = {
                                                let l19 = *ptr2
                                                    .add(5 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<*mut u8>();
                                                let l20 = *ptr2
                                                    .add(6 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<usize>();
                                                let len21 = l20;
                                                let bytes21 = _rt::Vec::from_raw_parts(
                                                    l19.cast(),
                                                    len21,
                                                    len21,
                                                );
                                                _rt::string_lift(bytes21)
                                            };
                                            Some(e)
                                        }
                                        _ => _rt::invalid_enum_discriminant(),
                                    },
                                }
                            };
                            V22::Error(e22)
                        }
                    };
                    let result23 = v22;
                    result23
                }
            }
        }
    }
}
#[rustfmt::skip]
mod _rt {
    #![allow(dead_code, clippy::all)]
    pub use alloc_crate::string::String;
    pub use alloc_crate::vec::Vec;
    pub unsafe fn string_lift(bytes: Vec<u8>) -> String {
        if cfg!(debug_assertions) {
            String::from_utf8(bytes).unwrap()
        } else {
            String::from_utf8_unchecked(bytes)
        }
    }
    pub unsafe fn cabi_dealloc(ptr: *mut u8, size: usize, align: usize) {
        if size == 0 {
            return;
        }
        let layout = alloc::Layout::from_size_align_unchecked(size, align);
        alloc::dealloc(ptr, layout);
    }
    pub unsafe fn invalid_enum_discriminant<T>() -> T {
        if cfg!(debug_assertions) {
            panic!("invalid enum discriminant")
        } else {
            unsafe { core::hint::unreachable_unchecked() }
        }
    }
    pub unsafe fn bool_lift(val: u8) -> bool {
        if cfg!(debug_assertions) {
            match val {
                0 => false,
                1 => true,
                _ => panic!("invalid bool discriminant"),
            }
        } else {
            val != 0
        }
    }
    extern crate alloc as alloc_crate;
    pub use alloc_crate::alloc;
}
#[cfg(target_arch = "wasm32")]
#[unsafe(
    link_section = "component-type:wit-bindgen:0.41.0:wasmcp:spin@0.1.0:mcp-spin-gateway:encoded world"
)]
#[doc(hidden)]
#[allow(clippy::octal_escapes)]
pub static __WIT_BINDGEN_COMPONENT_TYPE: [u8; 1139] = *b"\
\0asm\x0d\0\x01\0\0\x19\x16wit-component-encoding\x04\0\x07\xec\x07\x01A\x02\x01\
A\x0a\x01B\x19\x01r\x03\x04names\x0bdescriptions\x0cinput-schemas\x04\0\x04tool\x03\
\0\0\x01ks\x01r\x03\x04codez\x07messages\x04data\x02\x04\0\x05error\x03\0\x03\x01\
q\x02\x04text\x01s\0\x05error\x01\x04\0\x04\0\x0btool-result\x03\0\x05\x01r\x04\x03\
uris\x04names\x0bdescription\x02\x09mime-type\x02\x04\0\x0dresource-info\x03\0\x07\
\x01p}\x01k\x09\x01r\x04\x03uris\x09mime-type\x02\x04text\x02\x04blob\x0a\x04\0\x11\
resource-contents\x03\0\x0b\x01q\x02\x08contents\x01\x0c\0\x05error\x01\x04\0\x04\
\0\x0fresource-result\x03\0\x0d\x01r\x03\x04names\x0bdescription\x02\x08required\
\x7f\x04\0\x0fprompt-argument\x03\0\x0f\x01p\x10\x01r\x03\x04names\x0bdescriptio\
n\x02\x09arguments\x11\x04\0\x11prompt-descriptor\x03\0\x12\x01r\x02\x04roles\x07\
contents\x04\0\x0eprompt-message\x03\0\x14\x01p\x15\x01q\x02\x08messages\x01\x16\
\0\x05error\x01\x04\0\x04\0\x0dprompt-result\x03\0\x17\x03\0\x16wasmcp:mcp/types\
@0.1.0\x05\0\x02\x03\0\0\x04tool\x02\x03\0\0\x0btool-result\x02\x03\0\0\x0dresou\
rce-info\x02\x03\0\0\x0fresource-result\x02\x03\0\0\x11prompt-descriptor\x02\x03\
\0\0\x0dprompt-result\x01B\x1b\x02\x03\x02\x01\x01\x04\0\x04tool\x03\0\0\x02\x03\
\x02\x01\x02\x04\0\x0btool-result\x03\0\x02\x02\x03\x02\x01\x03\x04\0\x0dresourc\
e-info\x03\0\x04\x02\x03\x02\x01\x04\x04\0\x0fresource-result\x03\0\x06\x02\x03\x02\
\x01\x05\x04\0\x11prompt-descriptor\x03\0\x08\x02\x03\x02\x01\x06\x04\0\x0dpromp\
t-result\x03\0\x0a\x01p\x01\x01@\0\0\x0c\x04\0\x0alist-tools\x01\x0d\x01@\x02\x04\
names\x09argumentss\0\x03\x04\0\x09call-tool\x01\x0e\x01p\x05\x01@\0\0\x0f\x04\0\
\x0elist-resources\x01\x10\x01@\x01\x03uris\0\x07\x04\0\x0dread-resource\x01\x11\
\x01p\x09\x01@\0\0\x12\x04\0\x0clist-prompts\x01\x13\x01@\x02\x04names\x09argume\
ntss\0\x0b\x04\0\x0aget-prompt\x01\x14\x03\0\x18wasmcp:mcp/handler@0.1.0\x05\x07\
\x04\0\"wasmcp:spin/mcp-spin-gateway@0.1.0\x04\0\x0b\x16\x01\0\x10mcp-spin-gatew\
ay\x03\0\0\0G\x09producers\x01\x0cprocessed-by\x02\x0dwit-component\x070.227.1\x10\
wit-bindgen-rust\x060.41.0";
#[inline(never)]
#[doc(hidden)]
pub fn __link_custom_section_describing_imports() {
    wit_bindgen_rt::maybe_link_cabi_realloc();
}
