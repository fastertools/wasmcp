// Generated by `wit-bindgen` 0.41.0. DO NOT EDIT!
// Options used:
//   * runtime_path: "wit_bindgen_rt"
//   * additional derives ["serde::Serialize", "serde::Deserialize", "Clone"]
#[rustfmt::skip]
#[allow(dead_code, clippy::all)]
pub mod fastertools {
    pub mod mcp {
        /// Core type definitions for the Model Context Protocol
        /// These types are used across all MCP interfaces
        #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
        pub mod types {
            #[used]
            #[doc(hidden)]
            static __FORCE_SECTION_REF: fn() = super::super::super::__link_custom_section_describing_imports;
            use super::super::super::_rt;
            /// Role in a conversation
            #[repr(u8)]
            #[derive(
                Clone,
                Copy,
                Eq,
                Ord,
                PartialEq,
                PartialOrd,
                serde::Deserialize,
                serde::Serialize
            )]
            pub enum Role {
                User,
                Assistant,
            }
            impl ::core::fmt::Debug for Role {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    match self {
                        Role::User => f.debug_tuple("Role::User").finish(),
                        Role::Assistant => f.debug_tuple("Role::Assistant").finish(),
                    }
                }
            }
            impl Role {
                #[doc(hidden)]
                pub unsafe fn _lift(val: u8) -> Role {
                    if !cfg!(debug_assertions) {
                        return ::core::mem::transmute(val);
                    }
                    match val {
                        0 => Role::User,
                        1 => Role::Assistant,
                        _ => panic!("invalid enum discriminant"),
                    }
                }
            }
            /// JSON value as a string
            /// This is a JSON-encoded value that should be parsed/validated by implementations
            pub type JsonValue = _rt::String;
            /// Metadata fields for extensibility
            /// Key-value pairs where values are JSON-encoded strings
            pub type MetaFields = _rt::Vec<(_rt::String, _rt::String)>;
            /// Annotations provide hints to clients about how to handle data
            #[derive(Clone, serde::Deserialize, serde::Serialize)]
            pub struct Annotations {
                /// Who this data is intended for
                pub audience: Option<_rt::Vec<Role>>,
                /// Priority from 0.0 (least) to 1.0 (most important)
                /// Implementations SHOULD validate this is within [0.0, 1.0] range
                pub priority: Option<f64>,
                /// ISO 8601 timestamp of last modification
                /// Format: YYYY-MM-DDTHH:mm:ss[.sss]Z or Â±HH:MM offset
                pub last_modified: Option<_rt::String>,
            }
            impl ::core::fmt::Debug for Annotations {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("Annotations")
                        .field("audience", &self.audience)
                        .field("priority", &self.priority)
                        .field("last-modified", &self.last_modified)
                        .finish()
                }
            }
            /// Base metadata pattern used throughout the protocol
            #[derive(Clone, serde::Deserialize, serde::Serialize)]
            pub struct BaseMetadata {
                /// Programmatic identifier
                pub name: _rt::String,
                /// Human-readable display name
                pub title: Option<_rt::String>,
            }
            impl ::core::fmt::Debug for BaseMetadata {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("BaseMetadata")
                        .field("name", &self.name)
                        .field("title", &self.title)
                        .finish()
                }
            }
            /// Text content with optional annotations
            #[derive(Clone, serde::Deserialize, serde::Serialize)]
            pub struct TextContent {
                pub text: _rt::String,
                pub annotations: Option<Annotations>,
                pub meta: Option<MetaFields>,
            }
            impl ::core::fmt::Debug for TextContent {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("TextContent")
                        .field("text", &self.text)
                        .field("annotations", &self.annotations)
                        .field("meta", &self.meta)
                        .finish()
                }
            }
            /// Image content as binary data
            #[derive(Clone, serde::Deserialize, serde::Serialize)]
            pub struct ImageContent {
                /// Base64-encoded image data
                pub data: _rt::Vec<u8>,
                /// MIME type (e.g., "image/png", "image/jpeg")
                pub mime_type: _rt::String,
                pub annotations: Option<Annotations>,
                pub meta: Option<MetaFields>,
            }
            impl ::core::fmt::Debug for ImageContent {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("ImageContent")
                        .field("data", &self.data)
                        .field("mime-type", &self.mime_type)
                        .field("annotations", &self.annotations)
                        .field("meta", &self.meta)
                        .finish()
                }
            }
            /// Audio content as binary data
            #[derive(Clone, serde::Deserialize, serde::Serialize)]
            pub struct AudioContent {
                /// Base64-encoded audio data
                pub data: _rt::Vec<u8>,
                /// MIME type (e.g., "audio/wav", "audio/mp3")
                pub mime_type: _rt::String,
                pub annotations: Option<Annotations>,
                pub meta: Option<MetaFields>,
            }
            impl ::core::fmt::Debug for AudioContent {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("AudioContent")
                        .field("data", &self.data)
                        .field("mime-type", &self.mime_type)
                        .field("annotations", &self.annotations)
                        .field("meta", &self.meta)
                        .finish()
                }
            }
            /// Reference to a resource that the server can read
            /// Resource links included in prompts or tool results may not appear in resources/list
            #[derive(Clone, serde::Deserialize, serde::Serialize)]
            pub struct ResourceLink {
                /// URI of the resource
                pub uri: _rt::String,
                /// Programmatic identifier for the resource
                pub name: _rt::String,
                /// Human-readable display title (preferred for UI display)
                pub title: Option<_rt::String>,
                /// Description of what this resource represents
                pub description: Option<_rt::String>,
                /// MIME type of the resource, if known
                pub mime_type: Option<_rt::String>,
                /// Size in bytes (before encoding), if known
                pub size: Option<u64>,
                /// Client hints for handling
                pub annotations: Option<Annotations>,
                /// Extension metadata
                pub meta: Option<MetaFields>,
            }
            impl ::core::fmt::Debug for ResourceLink {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("ResourceLink")
                        .field("uri", &self.uri)
                        .field("name", &self.name)
                        .field("title", &self.title)
                        .field("description", &self.description)
                        .field("mime-type", &self.mime_type)
                        .field("size", &self.size)
                        .field("annotations", &self.annotations)
                        .field("meta", &self.meta)
                        .finish()
                }
            }
            #[derive(Clone, serde::Deserialize, serde::Serialize)]
            pub struct TextResourceContents {
                pub uri: _rt::String,
                pub mime_type: Option<_rt::String>,
                pub text: _rt::String,
                pub meta: Option<MetaFields>,
            }
            impl ::core::fmt::Debug for TextResourceContents {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("TextResourceContents")
                        .field("uri", &self.uri)
                        .field("mime-type", &self.mime_type)
                        .field("text", &self.text)
                        .field("meta", &self.meta)
                        .finish()
                }
            }
            #[derive(Clone, serde::Deserialize, serde::Serialize)]
            pub struct BlobResourceContents {
                pub uri: _rt::String,
                pub mime_type: Option<_rt::String>,
                /// Binary data
                pub blob: _rt::Vec<u8>,
                pub meta: Option<MetaFields>,
            }
            impl ::core::fmt::Debug for BlobResourceContents {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("BlobResourceContents")
                        .field("uri", &self.uri)
                        .field("mime-type", &self.mime_type)
                        .field("blob", &self.blob)
                        .field("meta", &self.meta)
                        .finish()
                }
            }
            /// Resource contents can be either text or binary
            #[derive(Clone, serde::Deserialize, serde::Serialize)]
            pub enum ResourceContents {
                Text(TextResourceContents),
                Blob(BlobResourceContents),
            }
            impl ::core::fmt::Debug for ResourceContents {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    match self {
                        ResourceContents::Text(e) => {
                            f.debug_tuple("ResourceContents::Text").field(e).finish()
                        }
                        ResourceContents::Blob(e) => {
                            f.debug_tuple("ResourceContents::Blob").field(e).finish()
                        }
                    }
                }
            }
            /// Embedded resource content
            /// The contents of a resource, embedded into a prompt or tool call result
            #[derive(Clone, serde::Deserialize, serde::Serialize)]
            pub struct EmbeddedResource {
                /// The actual resource contents (text or binary)
                pub contents: ResourceContents,
                /// Client hints for handling
                pub annotations: Option<Annotations>,
                /// Extension metadata
                pub meta: Option<MetaFields>,
            }
            impl ::core::fmt::Debug for EmbeddedResource {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("EmbeddedResource")
                        .field("contents", &self.contents)
                        .field("annotations", &self.annotations)
                        .field("meta", &self.meta)
                        .finish()
                }
            }
            /// Content block types that can be included in messages
            #[derive(Clone, serde::Deserialize, serde::Serialize)]
            pub enum ContentBlock {
                Text(TextContent),
                Image(ImageContent),
                Audio(AudioContent),
                ResourceLink(ResourceLink),
                EmbeddedResource(EmbeddedResource),
            }
            impl ::core::fmt::Debug for ContentBlock {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    match self {
                        ContentBlock::Text(e) => {
                            f.debug_tuple("ContentBlock::Text").field(e).finish()
                        }
                        ContentBlock::Image(e) => {
                            f.debug_tuple("ContentBlock::Image").field(e).finish()
                        }
                        ContentBlock::Audio(e) => {
                            f.debug_tuple("ContentBlock::Audio").field(e).finish()
                        }
                        ContentBlock::ResourceLink(e) => {
                            f.debug_tuple("ContentBlock::ResourceLink").field(e).finish()
                        }
                        ContentBlock::EmbeddedResource(e) => {
                            f.debug_tuple("ContentBlock::EmbeddedResource")
                                .field(e)
                                .finish()
                        }
                    }
                }
            }
            /// JSON Schema representation
            /// Kept as a string since JSON Schema is complex
            /// and typically validated by specialized libraries
            pub type JsonSchema = _rt::String;
            /// Standard JSON-RPC and MCP error codes
            #[derive(Clone, Copy, serde::Deserialize, serde::Serialize)]
            pub enum ErrorCode {
                /// JSON-RPC standard errors
                ParseError,
                /// -32700
                InvalidRequest,
                /// -32600
                MethodNotFound,
                /// -32601
                InvalidParams,
                /// -32602
                InternalError,
                /// -32603
                /// MCP-specific errors
                ResourceNotFound,
                ToolNotFound,
                PromptNotFound,
                Unauthorized,
                RateLimited,
                Timeout,
                Cancelled,
                /// Custom error with specific code
                CustomCode(i32),
            }
            impl ::core::fmt::Debug for ErrorCode {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    match self {
                        ErrorCode::ParseError => {
                            f.debug_tuple("ErrorCode::ParseError").finish()
                        }
                        ErrorCode::InvalidRequest => {
                            f.debug_tuple("ErrorCode::InvalidRequest").finish()
                        }
                        ErrorCode::MethodNotFound => {
                            f.debug_tuple("ErrorCode::MethodNotFound").finish()
                        }
                        ErrorCode::InvalidParams => {
                            f.debug_tuple("ErrorCode::InvalidParams").finish()
                        }
                        ErrorCode::InternalError => {
                            f.debug_tuple("ErrorCode::InternalError").finish()
                        }
                        ErrorCode::ResourceNotFound => {
                            f.debug_tuple("ErrorCode::ResourceNotFound").finish()
                        }
                        ErrorCode::ToolNotFound => {
                            f.debug_tuple("ErrorCode::ToolNotFound").finish()
                        }
                        ErrorCode::PromptNotFound => {
                            f.debug_tuple("ErrorCode::PromptNotFound").finish()
                        }
                        ErrorCode::Unauthorized => {
                            f.debug_tuple("ErrorCode::Unauthorized").finish()
                        }
                        ErrorCode::RateLimited => {
                            f.debug_tuple("ErrorCode::RateLimited").finish()
                        }
                        ErrorCode::Timeout => {
                            f.debug_tuple("ErrorCode::Timeout").finish()
                        }
                        ErrorCode::Cancelled => {
                            f.debug_tuple("ErrorCode::Cancelled").finish()
                        }
                        ErrorCode::CustomCode(e) => {
                            f.debug_tuple("ErrorCode::CustomCode").field(e).finish()
                        }
                    }
                }
            }
            /// Standard error structure
            #[derive(Clone, serde::Deserialize, serde::Serialize)]
            pub struct McpError {
                pub code: ErrorCode,
                pub message: _rt::String,
                /// Additional error context (JSON-encoded)
                pub data: Option<_rt::String>,
            }
            impl ::core::fmt::Debug for McpError {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("McpError")
                        .field("code", &self.code)
                        .field("message", &self.message)
                        .field("data", &self.data)
                        .finish()
                }
            }
            impl ::core::fmt::Display for McpError {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    write!(f, "{:?}", self)
                }
            }
            impl std::error::Error for McpError {}
            /// Pagination cursor for list operations
            pub type Cursor = _rt::String;
            /// Progress token for tracking long-running operations
            pub type ProgressToken = _rt::String;
            /// JSON-RPC request ID
            /// Can be either a string or number in JSON-RPC
            #[derive(Clone, serde::Deserialize, serde::Serialize)]
            pub enum RequestId {
                Str(_rt::String),
                Num(i64),
            }
            impl ::core::fmt::Debug for RequestId {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    match self {
                        RequestId::Str(e) => {
                            f.debug_tuple("RequestId::Str").field(e).finish()
                        }
                        RequestId::Num(e) => {
                            f.debug_tuple("RequestId::Num").field(e).finish()
                        }
                    }
                }
            }
            /// Message role for LLM interactions
            #[repr(u8)]
            #[derive(
                Clone,
                Copy,
                Eq,
                Ord,
                PartialEq,
                PartialOrd,
                serde::Deserialize,
                serde::Serialize
            )]
            pub enum MessageRole {
                User,
                Assistant,
                System,
            }
            impl ::core::fmt::Debug for MessageRole {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    match self {
                        MessageRole::User => f.debug_tuple("MessageRole::User").finish(),
                        MessageRole::Assistant => {
                            f.debug_tuple("MessageRole::Assistant").finish()
                        }
                        MessageRole::System => {
                            f.debug_tuple("MessageRole::System").finish()
                        }
                    }
                }
            }
            impl MessageRole {
                #[doc(hidden)]
                pub unsafe fn _lift(val: u8) -> MessageRole {
                    if !cfg!(debug_assertions) {
                        return ::core::mem::transmute(val);
                    }
                    match val {
                        0 => MessageRole::User,
                        1 => MessageRole::Assistant,
                        2 => MessageRole::System,
                        _ => panic!("invalid enum discriminant"),
                    }
                }
            }
            /// Hint for model selection
            #[derive(Clone, serde::Deserialize, serde::Serialize)]
            pub struct ModelHint {
                /// Name pattern to match (e.g., "claude", "gpt-4")
                pub name: Option<_rt::String>,
            }
            impl ::core::fmt::Debug for ModelHint {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("ModelHint").field("name", &self.name).finish()
                }
            }
            /// Model selection preferences for LLM sampling
            #[derive(Clone, serde::Deserialize, serde::Serialize)]
            pub struct ModelPreferences {
                /// Hints for model selection
                pub hints: Option<_rt::Vec<ModelHint>>,
                /// Priority for cost optimization (0.0-1.0)
                pub cost_priority: Option<f64>,
                /// Priority for speed (0.0-1.0)
                pub speed_priority: Option<f64>,
                /// Priority for intelligence/capability (0.0-1.0)
                pub intelligence_priority: Option<f64>,
            }
            impl ::core::fmt::Debug for ModelPreferences {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("ModelPreferences")
                        .field("hints", &self.hints)
                        .field("cost-priority", &self.cost_priority)
                        .field("speed-priority", &self.speed_priority)
                        .field("intelligence-priority", &self.intelligence_priority)
                        .finish()
                }
            }
            /// Resource template with URI template support (RFC 6570)
            #[derive(Clone, serde::Deserialize, serde::Serialize)]
            pub struct ResourceTemplate {
                /// URI template that can be expanded with variables
                pub uri_template: _rt::String,
                /// Identifier for the template
                pub name: _rt::String,
                /// Human-readable description
                pub description: Option<_rt::String>,
                /// Expected MIME type of resources
                pub mime_type: Option<_rt::String>,
            }
            impl ::core::fmt::Debug for ResourceTemplate {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("ResourceTemplate")
                        .field("uri-template", &self.uri_template)
                        .field("name", &self.name)
                        .field("description", &self.description)
                        .field("mime-type", &self.mime_type)
                        .finish()
                }
            }
        }
    }
}
#[rustfmt::skip]
#[allow(dead_code, clippy::all)]
pub mod exports {
    pub mod fastertools {
        pub mod mcp {
            #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
            pub mod authorization {
                #[used]
                #[doc(hidden)]
                static __FORCE_SECTION_REF: fn() = super::super::super::super::__link_custom_section_describing_imports;
                use super::super::super::super::_rt;
                pub type MetaFields = super::super::super::super::fastertools::mcp::types::MetaFields;
                /// Authorization context passed between components after successful authentication
                #[derive(Clone, serde::Deserialize, serde::Serialize)]
                pub struct AuthContext {
                    /// OAuth client ID that made the request
                    pub client_id: Option<_rt::String>,
                    /// Subject (user ID) from the token
                    pub user_id: Option<_rt::String>,
                    /// OAuth scopes granted to this token
                    pub scopes: _rt::Vec<_rt::String>,
                    /// Token issuer URL
                    pub issuer: Option<_rt::String>,
                    /// Audience claim from token
                    pub audience: Option<_rt::String>,
                    /// Additional claims from token as key-value pairs
                    pub claims: MetaFields,
                    /// Expiration timestamp (Unix seconds)
                    pub exp: Option<u64>,
                    /// Issued at timestamp (Unix seconds)
                    pub iat: Option<u64>,
                }
                impl ::core::fmt::Debug for AuthContext {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter<'_>,
                    ) -> ::core::fmt::Result {
                        f.debug_struct("AuthContext")
                            .field("client-id", &self.client_id)
                            .field("user-id", &self.user_id)
                            .field("scopes", &self.scopes)
                            .field("issuer", &self.issuer)
                            .field("audience", &self.audience)
                            .field("claims", &self.claims)
                            .field("exp", &self.exp)
                            .field("iat", &self.iat)
                            .finish()
                    }
                }
                /// Authorization request containing all context needed for authorization decisions
                #[derive(Clone, serde::Deserialize, serde::Serialize)]
                pub struct AuthRequest {
                    /// Bearer token extracted from Authorization header
                    pub token: _rt::String,
                    /// HTTP method (GET, POST, etc.)
                    pub method: _rt::String,
                    /// Request path
                    pub path: _rt::String,
                    /// Request headers as key-value pairs
                    pub headers: _rt::Vec<(_rt::String, _rt::String)>,
                    /// Request body for policy evaluation (e.g., MCP JSON-RPC payload)
                    pub body: Option<_rt::Vec<u8>>,
                    /// Expected issuer for validation
                    pub expected_issuer: _rt::String,
                    /// Expected audiences for validation (token must match at least one)
                    pub expected_audiences: _rt::Vec<_rt::String>,
                    /// JWKS URI for key discovery
                    pub jwks_uri: _rt::String,
                    /// Optional Rego policy to evaluate (if not provided, allows all authenticated requests)
                    pub policy: Option<_rt::String>,
                    /// Optional data for policy evaluation (JSON string)
                    pub policy_data: Option<_rt::String>,
                }
                impl ::core::fmt::Debug for AuthRequest {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter<'_>,
                    ) -> ::core::fmt::Result {
                        f.debug_struct("AuthRequest")
                            .field("token", &self.token)
                            .field("method", &self.method)
                            .field("path", &self.path)
                            .field("headers", &self.headers)
                            .field("body", &self.body)
                            .field("expected-issuer", &self.expected_issuer)
                            .field("expected-audiences", &self.expected_audiences)
                            .field("jwks-uri", &self.jwks_uri)
                            .field("policy", &self.policy)
                            .field("policy-data", &self.policy_data)
                            .finish()
                    }
                }
                /// Authorization error details for proper OAuth 2.0 error responses
                #[derive(Clone, serde::Deserialize, serde::Serialize)]
                pub struct AuthError {
                    /// HTTP status code (401, 403, etc.)
                    pub status: u16,
                    /// OAuth error code (invalid_token, insufficient_scope, etc.)
                    pub error_code: _rt::String,
                    /// Human-readable error description
                    pub description: _rt::String,
                    /// WWW-Authenticate header value for 401 responses
                    pub www_authenticate: Option<_rt::String>,
                }
                impl ::core::fmt::Debug for AuthError {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter<'_>,
                    ) -> ::core::fmt::Result {
                        f.debug_struct("AuthError")
                            .field("status", &self.status)
                            .field("error-code", &self.error_code)
                            .field("description", &self.description)
                            .field("www-authenticate", &self.www_authenticate)
                            .finish()
                    }
                }
                impl ::core::fmt::Display for AuthError {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter<'_>,
                    ) -> ::core::fmt::Result {
                        write!(f, "{:?}", self)
                    }
                }
                impl std::error::Error for AuthError {}
                /// Authorization response - either authorized with context or unauthorized with error
                #[derive(Clone, serde::Deserialize, serde::Serialize)]
                pub enum AuthResponse {
                    /// Request is authorized, includes auth context for downstream use
                    Authorized(AuthContext),
                    /// Request is unauthorized, includes error details for response
                    Unauthorized(AuthError),
                }
                impl ::core::fmt::Debug for AuthResponse {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter<'_>,
                    ) -> ::core::fmt::Result {
                        match self {
                            AuthResponse::Authorized(e) => {
                                f.debug_tuple("AuthResponse::Authorized").field(e).finish()
                            }
                            AuthResponse::Unauthorized(e) => {
                                f.debug_tuple("AuthResponse::Unauthorized")
                                    .field(e)
                                    .finish()
                            }
                        }
                    }
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_authorize_cabi<T: Guest>(
                    arg0: *mut u8,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let l0 = *arg0.add(0).cast::<*mut u8>();
                    let l1 = *arg0
                        .add(::core::mem::size_of::<*const u8>())
                        .cast::<usize>();
                    let len2 = l1;
                    let bytes2 = _rt::Vec::from_raw_parts(l0.cast(), len2, len2);
                    let l3 = *arg0
                        .add(2 * ::core::mem::size_of::<*const u8>())
                        .cast::<*mut u8>();
                    let l4 = *arg0
                        .add(3 * ::core::mem::size_of::<*const u8>())
                        .cast::<usize>();
                    let len5 = l4;
                    let bytes5 = _rt::Vec::from_raw_parts(l3.cast(), len5, len5);
                    let l6 = *arg0
                        .add(4 * ::core::mem::size_of::<*const u8>())
                        .cast::<*mut u8>();
                    let l7 = *arg0
                        .add(5 * ::core::mem::size_of::<*const u8>())
                        .cast::<usize>();
                    let len8 = l7;
                    let bytes8 = _rt::Vec::from_raw_parts(l6.cast(), len8, len8);
                    let l9 = *arg0
                        .add(6 * ::core::mem::size_of::<*const u8>())
                        .cast::<*mut u8>();
                    let l10 = *arg0
                        .add(7 * ::core::mem::size_of::<*const u8>())
                        .cast::<usize>();
                    let base17 = l9;
                    let len17 = l10;
                    let mut result17 = _rt::Vec::with_capacity(len17);
                    for i in 0..len17 {
                        let base = base17
                            .add(i * (4 * ::core::mem::size_of::<*const u8>()));
                        let e17 = {
                            let l11 = *base.add(0).cast::<*mut u8>();
                            let l12 = *base
                                .add(::core::mem::size_of::<*const u8>())
                                .cast::<usize>();
                            let len13 = l12;
                            let bytes13 = _rt::Vec::from_raw_parts(
                                l11.cast(),
                                len13,
                                len13,
                            );
                            let l14 = *base
                                .add(2 * ::core::mem::size_of::<*const u8>())
                                .cast::<*mut u8>();
                            let l15 = *base
                                .add(3 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>();
                            let len16 = l15;
                            let bytes16 = _rt::Vec::from_raw_parts(
                                l14.cast(),
                                len16,
                                len16,
                            );
                            (_rt::string_lift(bytes13), _rt::string_lift(bytes16))
                        };
                        result17.push(e17);
                    }
                    _rt::cabi_dealloc(
                        base17,
                        len17 * (4 * ::core::mem::size_of::<*const u8>()),
                        ::core::mem::size_of::<*const u8>(),
                    );
                    let l18 = i32::from(
                        *arg0.add(8 * ::core::mem::size_of::<*const u8>()).cast::<u8>(),
                    );
                    let l22 = *arg0
                        .add(11 * ::core::mem::size_of::<*const u8>())
                        .cast::<*mut u8>();
                    let l23 = *arg0
                        .add(12 * ::core::mem::size_of::<*const u8>())
                        .cast::<usize>();
                    let len24 = l23;
                    let bytes24 = _rt::Vec::from_raw_parts(l22.cast(), len24, len24);
                    let l25 = *arg0
                        .add(13 * ::core::mem::size_of::<*const u8>())
                        .cast::<*mut u8>();
                    let l26 = *arg0
                        .add(14 * ::core::mem::size_of::<*const u8>())
                        .cast::<usize>();
                    let base30 = l25;
                    let len30 = l26;
                    let mut result30 = _rt::Vec::with_capacity(len30);
                    for i in 0..len30 {
                        let base = base30
                            .add(i * (2 * ::core::mem::size_of::<*const u8>()));
                        let e30 = {
                            let l27 = *base.add(0).cast::<*mut u8>();
                            let l28 = *base
                                .add(::core::mem::size_of::<*const u8>())
                                .cast::<usize>();
                            let len29 = l28;
                            let bytes29 = _rt::Vec::from_raw_parts(
                                l27.cast(),
                                len29,
                                len29,
                            );
                            _rt::string_lift(bytes29)
                        };
                        result30.push(e30);
                    }
                    _rt::cabi_dealloc(
                        base30,
                        len30 * (2 * ::core::mem::size_of::<*const u8>()),
                        ::core::mem::size_of::<*const u8>(),
                    );
                    let l31 = *arg0
                        .add(15 * ::core::mem::size_of::<*const u8>())
                        .cast::<*mut u8>();
                    let l32 = *arg0
                        .add(16 * ::core::mem::size_of::<*const u8>())
                        .cast::<usize>();
                    let len33 = l32;
                    let bytes33 = _rt::Vec::from_raw_parts(l31.cast(), len33, len33);
                    let l34 = i32::from(
                        *arg0.add(17 * ::core::mem::size_of::<*const u8>()).cast::<u8>(),
                    );
                    let l38 = i32::from(
                        *arg0.add(20 * ::core::mem::size_of::<*const u8>()).cast::<u8>(),
                    );
                    let result42 = T::authorize(AuthRequest {
                        token: _rt::string_lift(bytes2),
                        method: _rt::string_lift(bytes5),
                        path: _rt::string_lift(bytes8),
                        headers: result17,
                        body: match l18 {
                            0 => None,
                            1 => {
                                let e = {
                                    let l19 = *arg0
                                        .add(9 * ::core::mem::size_of::<*const u8>())
                                        .cast::<*mut u8>();
                                    let l20 = *arg0
                                        .add(10 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    let len21 = l20;
                                    _rt::Vec::from_raw_parts(l19.cast(), len21, len21)
                                };
                                Some(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                        },
                        expected_issuer: _rt::string_lift(bytes24),
                        expected_audiences: result30,
                        jwks_uri: _rt::string_lift(bytes33),
                        policy: match l34 {
                            0 => None,
                            1 => {
                                let e = {
                                    let l35 = *arg0
                                        .add(18 * ::core::mem::size_of::<*const u8>())
                                        .cast::<*mut u8>();
                                    let l36 = *arg0
                                        .add(19 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    let len37 = l36;
                                    let bytes37 = _rt::Vec::from_raw_parts(
                                        l35.cast(),
                                        len37,
                                        len37,
                                    );
                                    _rt::string_lift(bytes37)
                                };
                                Some(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                        },
                        policy_data: match l38 {
                            0 => None,
                            1 => {
                                let e = {
                                    let l39 = *arg0
                                        .add(21 * ::core::mem::size_of::<*const u8>())
                                        .cast::<*mut u8>();
                                    let l40 = *arg0
                                        .add(22 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    let len41 = l40;
                                    let bytes41 = _rt::Vec::from_raw_parts(
                                        l39.cast(),
                                        len41,
                                        len41,
                                    );
                                    _rt::string_lift(bytes41)
                                };
                                Some(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                        },
                    });
                    _rt::cabi_dealloc(
                        arg0,
                        23 * ::core::mem::size_of::<*const u8>(),
                        ::core::mem::size_of::<*const u8>(),
                    );
                    let ptr43 = (&raw mut _RET_AREA.0).cast::<u8>();
                    match result42 {
                        AuthResponse::Authorized(e) => {
                            *ptr43.add(0).cast::<u8>() = (0i32) as u8;
                            let AuthContext {
                                client_id: client_id44,
                                user_id: user_id44,
                                scopes: scopes44,
                                issuer: issuer44,
                                audience: audience44,
                                claims: claims44,
                                exp: exp44,
                                iat: iat44,
                            } = e;
                            match client_id44 {
                                Some(e) => {
                                    *ptr43.add(8).cast::<u8>() = (1i32) as u8;
                                    let vec45 = (e.into_bytes()).into_boxed_slice();
                                    let ptr45 = vec45.as_ptr().cast::<u8>();
                                    let len45 = vec45.len();
                                    ::core::mem::forget(vec45);
                                    *ptr43
                                        .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len45;
                                    *ptr43
                                        .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<*mut u8>() = ptr45.cast_mut();
                                }
                                None => {
                                    *ptr43.add(8).cast::<u8>() = (0i32) as u8;
                                }
                            };
                            match user_id44 {
                                Some(e) => {
                                    *ptr43
                                        .add(8 + 3 * ::core::mem::size_of::<*const u8>())
                                        .cast::<u8>() = (1i32) as u8;
                                    let vec46 = (e.into_bytes()).into_boxed_slice();
                                    let ptr46 = vec46.as_ptr().cast::<u8>();
                                    let len46 = vec46.len();
                                    ::core::mem::forget(vec46);
                                    *ptr43
                                        .add(8 + 5 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len46;
                                    *ptr43
                                        .add(8 + 4 * ::core::mem::size_of::<*const u8>())
                                        .cast::<*mut u8>() = ptr46.cast_mut();
                                }
                                None => {
                                    *ptr43
                                        .add(8 + 3 * ::core::mem::size_of::<*const u8>())
                                        .cast::<u8>() = (0i32) as u8;
                                }
                            };
                            let vec48 = scopes44;
                            let len48 = vec48.len();
                            let layout48 = _rt::alloc::Layout::from_size_align_unchecked(
                                vec48.len() * (2 * ::core::mem::size_of::<*const u8>()),
                                ::core::mem::size_of::<*const u8>(),
                            );
                            let result48 = if layout48.size() != 0 {
                                let ptr = _rt::alloc::alloc(layout48).cast::<u8>();
                                if ptr.is_null() {
                                    _rt::alloc::handle_alloc_error(layout48);
                                }
                                ptr
                            } else {
                                ::core::ptr::null_mut()
                            };
                            for (i, e) in vec48.into_iter().enumerate() {
                                let base = result48
                                    .add(i * (2 * ::core::mem::size_of::<*const u8>()));
                                {
                                    let vec47 = (e.into_bytes()).into_boxed_slice();
                                    let ptr47 = vec47.as_ptr().cast::<u8>();
                                    let len47 = vec47.len();
                                    ::core::mem::forget(vec47);
                                    *base
                                        .add(::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len47;
                                    *base.add(0).cast::<*mut u8>() = ptr47.cast_mut();
                                }
                            }
                            *ptr43
                                .add(8 + 7 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>() = len48;
                            *ptr43
                                .add(8 + 6 * ::core::mem::size_of::<*const u8>())
                                .cast::<*mut u8>() = result48;
                            match issuer44 {
                                Some(e) => {
                                    *ptr43
                                        .add(8 + 8 * ::core::mem::size_of::<*const u8>())
                                        .cast::<u8>() = (1i32) as u8;
                                    let vec49 = (e.into_bytes()).into_boxed_slice();
                                    let ptr49 = vec49.as_ptr().cast::<u8>();
                                    let len49 = vec49.len();
                                    ::core::mem::forget(vec49);
                                    *ptr43
                                        .add(8 + 10 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len49;
                                    *ptr43
                                        .add(8 + 9 * ::core::mem::size_of::<*const u8>())
                                        .cast::<*mut u8>() = ptr49.cast_mut();
                                }
                                None => {
                                    *ptr43
                                        .add(8 + 8 * ::core::mem::size_of::<*const u8>())
                                        .cast::<u8>() = (0i32) as u8;
                                }
                            };
                            match audience44 {
                                Some(e) => {
                                    *ptr43
                                        .add(8 + 11 * ::core::mem::size_of::<*const u8>())
                                        .cast::<u8>() = (1i32) as u8;
                                    let vec50 = (e.into_bytes()).into_boxed_slice();
                                    let ptr50 = vec50.as_ptr().cast::<u8>();
                                    let len50 = vec50.len();
                                    ::core::mem::forget(vec50);
                                    *ptr43
                                        .add(8 + 13 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len50;
                                    *ptr43
                                        .add(8 + 12 * ::core::mem::size_of::<*const u8>())
                                        .cast::<*mut u8>() = ptr50.cast_mut();
                                }
                                None => {
                                    *ptr43
                                        .add(8 + 11 * ::core::mem::size_of::<*const u8>())
                                        .cast::<u8>() = (0i32) as u8;
                                }
                            };
                            let vec54 = claims44;
                            let len54 = vec54.len();
                            let layout54 = _rt::alloc::Layout::from_size_align_unchecked(
                                vec54.len() * (4 * ::core::mem::size_of::<*const u8>()),
                                ::core::mem::size_of::<*const u8>(),
                            );
                            let result54 = if layout54.size() != 0 {
                                let ptr = _rt::alloc::alloc(layout54).cast::<u8>();
                                if ptr.is_null() {
                                    _rt::alloc::handle_alloc_error(layout54);
                                }
                                ptr
                            } else {
                                ::core::ptr::null_mut()
                            };
                            for (i, e) in vec54.into_iter().enumerate() {
                                let base = result54
                                    .add(i * (4 * ::core::mem::size_of::<*const u8>()));
                                {
                                    let (t51_0, t51_1) = e;
                                    let vec52 = (t51_0.into_bytes()).into_boxed_slice();
                                    let ptr52 = vec52.as_ptr().cast::<u8>();
                                    let len52 = vec52.len();
                                    ::core::mem::forget(vec52);
                                    *base
                                        .add(::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len52;
                                    *base.add(0).cast::<*mut u8>() = ptr52.cast_mut();
                                    let vec53 = (t51_1.into_bytes()).into_boxed_slice();
                                    let ptr53 = vec53.as_ptr().cast::<u8>();
                                    let len53 = vec53.len();
                                    ::core::mem::forget(vec53);
                                    *base
                                        .add(3 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len53;
                                    *base
                                        .add(2 * ::core::mem::size_of::<*const u8>())
                                        .cast::<*mut u8>() = ptr53.cast_mut();
                                }
                            }
                            *ptr43
                                .add(8 + 15 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>() = len54;
                            *ptr43
                                .add(8 + 14 * ::core::mem::size_of::<*const u8>())
                                .cast::<*mut u8>() = result54;
                            match exp44 {
                                Some(e) => {
                                    *ptr43
                                        .add(8 + 16 * ::core::mem::size_of::<*const u8>())
                                        .cast::<u8>() = (1i32) as u8;
                                    *ptr43
                                        .add(16 + 16 * ::core::mem::size_of::<*const u8>())
                                        .cast::<i64>() = _rt::as_i64(e);
                                }
                                None => {
                                    *ptr43
                                        .add(8 + 16 * ::core::mem::size_of::<*const u8>())
                                        .cast::<u8>() = (0i32) as u8;
                                }
                            };
                            match iat44 {
                                Some(e) => {
                                    *ptr43
                                        .add(24 + 16 * ::core::mem::size_of::<*const u8>())
                                        .cast::<u8>() = (1i32) as u8;
                                    *ptr43
                                        .add(32 + 16 * ::core::mem::size_of::<*const u8>())
                                        .cast::<i64>() = _rt::as_i64(e);
                                }
                                None => {
                                    *ptr43
                                        .add(24 + 16 * ::core::mem::size_of::<*const u8>())
                                        .cast::<u8>() = (0i32) as u8;
                                }
                            };
                        }
                        AuthResponse::Unauthorized(e) => {
                            *ptr43.add(0).cast::<u8>() = (1i32) as u8;
                            let AuthError {
                                status: status55,
                                error_code: error_code55,
                                description: description55,
                                www_authenticate: www_authenticate55,
                            } = e;
                            *ptr43.add(8).cast::<u16>() = (_rt::as_i32(status55)) as u16;
                            let vec56 = (error_code55.into_bytes()).into_boxed_slice();
                            let ptr56 = vec56.as_ptr().cast::<u8>();
                            let len56 = vec56.len();
                            ::core::mem::forget(vec56);
                            *ptr43
                                .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>() = len56;
                            *ptr43
                                .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                .cast::<*mut u8>() = ptr56.cast_mut();
                            let vec57 = (description55.into_bytes()).into_boxed_slice();
                            let ptr57 = vec57.as_ptr().cast::<u8>();
                            let len57 = vec57.len();
                            ::core::mem::forget(vec57);
                            *ptr43
                                .add(8 + 4 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>() = len57;
                            *ptr43
                                .add(8 + 3 * ::core::mem::size_of::<*const u8>())
                                .cast::<*mut u8>() = ptr57.cast_mut();
                            match www_authenticate55 {
                                Some(e) => {
                                    *ptr43
                                        .add(8 + 5 * ::core::mem::size_of::<*const u8>())
                                        .cast::<u8>() = (1i32) as u8;
                                    let vec58 = (e.into_bytes()).into_boxed_slice();
                                    let ptr58 = vec58.as_ptr().cast::<u8>();
                                    let len58 = vec58.len();
                                    ::core::mem::forget(vec58);
                                    *ptr43
                                        .add(8 + 7 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len58;
                                    *ptr43
                                        .add(8 + 6 * ::core::mem::size_of::<*const u8>())
                                        .cast::<*mut u8>() = ptr58.cast_mut();
                                }
                                None => {
                                    *ptr43
                                        .add(8 + 5 * ::core::mem::size_of::<*const u8>())
                                        .cast::<u8>() = (0i32) as u8;
                                }
                            };
                        }
                    }
                    ptr43
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn __post_return_authorize<T: Guest>(arg0: *mut u8) {
                    let l0 = i32::from(*arg0.add(0).cast::<u8>());
                    match l0 {
                        0 => {
                            let l1 = i32::from(*arg0.add(8).cast::<u8>());
                            match l1 {
                                0 => {}
                                _ => {
                                    let l2 = *arg0
                                        .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<*mut u8>();
                                    let l3 = *arg0
                                        .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l2, l3, 1);
                                }
                            }
                            let l4 = i32::from(
                                *arg0
                                    .add(8 + 3 * ::core::mem::size_of::<*const u8>())
                                    .cast::<u8>(),
                            );
                            match l4 {
                                0 => {}
                                _ => {
                                    let l5 = *arg0
                                        .add(8 + 4 * ::core::mem::size_of::<*const u8>())
                                        .cast::<*mut u8>();
                                    let l6 = *arg0
                                        .add(8 + 5 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l5, l6, 1);
                                }
                            }
                            let l7 = *arg0
                                .add(8 + 6 * ::core::mem::size_of::<*const u8>())
                                .cast::<*mut u8>();
                            let l8 = *arg0
                                .add(8 + 7 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>();
                            let base11 = l7;
                            let len11 = l8;
                            for i in 0..len11 {
                                let base = base11
                                    .add(i * (2 * ::core::mem::size_of::<*const u8>()));
                                {
                                    let l9 = *base.add(0).cast::<*mut u8>();
                                    let l10 = *base
                                        .add(::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l9, l10, 1);
                                }
                            }
                            _rt::cabi_dealloc(
                                base11,
                                len11 * (2 * ::core::mem::size_of::<*const u8>()),
                                ::core::mem::size_of::<*const u8>(),
                            );
                            let l12 = i32::from(
                                *arg0
                                    .add(8 + 8 * ::core::mem::size_of::<*const u8>())
                                    .cast::<u8>(),
                            );
                            match l12 {
                                0 => {}
                                _ => {
                                    let l13 = *arg0
                                        .add(8 + 9 * ::core::mem::size_of::<*const u8>())
                                        .cast::<*mut u8>();
                                    let l14 = *arg0
                                        .add(8 + 10 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l13, l14, 1);
                                }
                            }
                            let l15 = i32::from(
                                *arg0
                                    .add(8 + 11 * ::core::mem::size_of::<*const u8>())
                                    .cast::<u8>(),
                            );
                            match l15 {
                                0 => {}
                                _ => {
                                    let l16 = *arg0
                                        .add(8 + 12 * ::core::mem::size_of::<*const u8>())
                                        .cast::<*mut u8>();
                                    let l17 = *arg0
                                        .add(8 + 13 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l16, l17, 1);
                                }
                            }
                            let l18 = *arg0
                                .add(8 + 14 * ::core::mem::size_of::<*const u8>())
                                .cast::<*mut u8>();
                            let l19 = *arg0
                                .add(8 + 15 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>();
                            let base24 = l18;
                            let len24 = l19;
                            for i in 0..len24 {
                                let base = base24
                                    .add(i * (4 * ::core::mem::size_of::<*const u8>()));
                                {
                                    let l20 = *base.add(0).cast::<*mut u8>();
                                    let l21 = *base
                                        .add(::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l20, l21, 1);
                                    let l22 = *base
                                        .add(2 * ::core::mem::size_of::<*const u8>())
                                        .cast::<*mut u8>();
                                    let l23 = *base
                                        .add(3 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l22, l23, 1);
                                }
                            }
                            _rt::cabi_dealloc(
                                base24,
                                len24 * (4 * ::core::mem::size_of::<*const u8>()),
                                ::core::mem::size_of::<*const u8>(),
                            );
                        }
                        _ => {
                            let l25 = *arg0
                                .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                .cast::<*mut u8>();
                            let l26 = *arg0
                                .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>();
                            _rt::cabi_dealloc(l25, l26, 1);
                            let l27 = *arg0
                                .add(8 + 3 * ::core::mem::size_of::<*const u8>())
                                .cast::<*mut u8>();
                            let l28 = *arg0
                                .add(8 + 4 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>();
                            _rt::cabi_dealloc(l27, l28, 1);
                            let l29 = i32::from(
                                *arg0
                                    .add(8 + 5 * ::core::mem::size_of::<*const u8>())
                                    .cast::<u8>(),
                            );
                            match l29 {
                                0 => {}
                                _ => {
                                    let l30 = *arg0
                                        .add(8 + 6 * ::core::mem::size_of::<*const u8>())
                                        .cast::<*mut u8>();
                                    let l31 = *arg0
                                        .add(8 + 7 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l30, l31, 1);
                                }
                            }
                        }
                    }
                }
                pub trait Guest {
                    /// Main authorization function - validates token and applies policies
                    fn authorize(request: AuthRequest) -> AuthResponse;
                }
                #[doc(hidden)]
                macro_rules! __export_fastertools_mcp_authorization_0_1_16_cabi {
                    ($ty:ident with_types_in $($path_to_types:tt)*) => {
                        const _ : () = { #[unsafe (export_name =
                        "fastertools:mcp/authorization@0.1.16#authorize")] unsafe extern
                        "C" fn export_authorize(arg0 : * mut u8,) -> * mut u8 { unsafe {
                        $($path_to_types)*:: _export_authorize_cabi::<$ty > (arg0) } }
                        #[unsafe (export_name =
                        "cabi_post_fastertools:mcp/authorization@0.1.16#authorize")]
                        unsafe extern "C" fn _post_return_authorize(arg0 : * mut u8,) {
                        unsafe { $($path_to_types)*:: __post_return_authorize::<$ty >
                        (arg0) } } };
                    };
                }
                #[doc(hidden)]
                pub(crate) use __export_fastertools_mcp_authorization_0_1_16_cabi;
                #[repr(align(8))]
                struct _RetArea(
                    [::core::mem::MaybeUninit<
                        u8,
                    >; 40 + 16 * ::core::mem::size_of::<*const u8>()],
                );
                static mut _RET_AREA: _RetArea = _RetArea(
                    [::core::mem::MaybeUninit::uninit(); 40
                        + 16 * ::core::mem::size_of::<*const u8>()],
                );
            }
            /// JWT token validation interface
            #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
            pub mod jwt_validator {
                #[used]
                #[doc(hidden)]
                static __FORCE_SECTION_REF: fn() = super::super::super::super::__link_custom_section_describing_imports;
                use super::super::super::super::_rt;
                pub type JsonValue = super::super::super::super::fastertools::mcp::types::JsonValue;
                /// JWT validation request
                #[derive(Clone, serde::Deserialize, serde::Serialize)]
                pub struct JwtRequest {
                    /// JWT token to validate
                    pub token: _rt::String,
                    /// Expected issuer
                    pub expected_issuer: _rt::String,
                    /// Expected audiences (token must match at least one)
                    pub expected_audiences: _rt::Vec<_rt::String>,
                    /// JWKS URI for fetching public keys
                    pub jwks_uri: _rt::String,
                    /// Optional JWKS JSON for offline validation
                    pub jwks_json: Option<_rt::String>,
                    /// Validate token expiration (default: true)
                    pub validate_exp: Option<bool>,
                    /// Validate not-before claim (default: true)
                    pub validate_nbf: Option<bool>,
                    /// Clock skew tolerance in seconds (default: 60)
                    pub clock_skew: Option<u64>,
                }
                impl ::core::fmt::Debug for JwtRequest {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter<'_>,
                    ) -> ::core::fmt::Result {
                        f.debug_struct("JwtRequest")
                            .field("token", &self.token)
                            .field("expected-issuer", &self.expected_issuer)
                            .field("expected-audiences", &self.expected_audiences)
                            .field("jwks-uri", &self.jwks_uri)
                            .field("jwks-json", &self.jwks_json)
                            .field("validate-exp", &self.validate_exp)
                            .field("validate-nbf", &self.validate_nbf)
                            .field("clock-skew", &self.clock_skew)
                            .finish()
                    }
                }
                /// JWT validation error types
                #[repr(u8)]
                #[derive(
                    Clone,
                    Copy,
                    Eq,
                    Ord,
                    PartialEq,
                    PartialOrd,
                    serde::Deserialize,
                    serde::Serialize
                )]
                pub enum JwtError {
                    /// Token format is invalid
                    Malformed,
                    /// Token signature verification failed
                    InvalidSignature,
                    /// Token has expired
                    Expired,
                    /// Token not yet valid (nbf claim)
                    NotYetValid,
                    /// Issuer doesn't match expected
                    InvalidIssuer,
                    /// Audience doesn't match expected
                    InvalidAudience,
                    /// Required claim is missing
                    MissingClaim,
                    /// JWKS fetch or parse error
                    JwksError,
                    /// Unknown key ID
                    UnknownKid,
                    /// Other validation error
                    Other,
                }
                impl ::core::fmt::Debug for JwtError {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter<'_>,
                    ) -> ::core::fmt::Result {
                        match self {
                            JwtError::Malformed => {
                                f.debug_tuple("JwtError::Malformed").finish()
                            }
                            JwtError::InvalidSignature => {
                                f.debug_tuple("JwtError::InvalidSignature").finish()
                            }
                            JwtError::Expired => {
                                f.debug_tuple("JwtError::Expired").finish()
                            }
                            JwtError::NotYetValid => {
                                f.debug_tuple("JwtError::NotYetValid").finish()
                            }
                            JwtError::InvalidIssuer => {
                                f.debug_tuple("JwtError::InvalidIssuer").finish()
                            }
                            JwtError::InvalidAudience => {
                                f.debug_tuple("JwtError::InvalidAudience").finish()
                            }
                            JwtError::MissingClaim => {
                                f.debug_tuple("JwtError::MissingClaim").finish()
                            }
                            JwtError::JwksError => {
                                f.debug_tuple("JwtError::JwksError").finish()
                            }
                            JwtError::UnknownKid => {
                                f.debug_tuple("JwtError::UnknownKid").finish()
                            }
                            JwtError::Other => f.debug_tuple("JwtError::Other").finish(),
                        }
                    }
                }
                impl JwtError {
                    #[doc(hidden)]
                    pub unsafe fn _lift(val: u8) -> JwtError {
                        if !cfg!(debug_assertions) {
                            return ::core::mem::transmute(val);
                        }
                        match val {
                            0 => JwtError::Malformed,
                            1 => JwtError::InvalidSignature,
                            2 => JwtError::Expired,
                            3 => JwtError::NotYetValid,
                            4 => JwtError::InvalidIssuer,
                            5 => JwtError::InvalidAudience,
                            6 => JwtError::MissingClaim,
                            7 => JwtError::JwksError,
                            8 => JwtError::UnknownKid,
                            9 => JwtError::Other,
                            _ => panic!("invalid enum discriminant"),
                        }
                    }
                }
                /// Validated JWT claims
                #[derive(Clone, serde::Deserialize, serde::Serialize)]
                pub struct JwtClaims {
                    /// Subject (user ID)
                    pub sub: _rt::String,
                    /// Issuer
                    pub iss: _rt::String,
                    /// Audience
                    pub aud: Option<_rt::Vec<_rt::String>>,
                    /// Expiration time (Unix timestamp)
                    pub exp: Option<u64>,
                    /// Issued at (Unix timestamp)
                    pub iat: Option<u64>,
                    /// Not before (Unix timestamp)
                    pub nbf: Option<u64>,
                    /// JWT ID
                    pub jti: Option<_rt::String>,
                    /// OAuth scopes (from scope claim)
                    pub scopes: _rt::Vec<_rt::String>,
                    /// OAuth client ID (from azp or client_id claim)
                    pub client_id: Option<_rt::String>,
                    /// Additional claims as JSON key-value pairs
                    pub additional_claims: _rt::Vec<(_rt::String, JsonValue)>,
                }
                impl ::core::fmt::Debug for JwtClaims {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter<'_>,
                    ) -> ::core::fmt::Result {
                        f.debug_struct("JwtClaims")
                            .field("sub", &self.sub)
                            .field("iss", &self.iss)
                            .field("aud", &self.aud)
                            .field("exp", &self.exp)
                            .field("iat", &self.iat)
                            .field("nbf", &self.nbf)
                            .field("jti", &self.jti)
                            .field("scopes", &self.scopes)
                            .field("client-id", &self.client_id)
                            .field("additional-claims", &self.additional_claims)
                            .finish()
                    }
                }
                /// JWT validation result
                #[derive(Clone, serde::Deserialize, serde::Serialize)]
                pub enum JwtResult {
                    /// Token is valid with extracted claims
                    Valid(JwtClaims),
                    /// Token is invalid with error reason
                    Invalid(JwtError),
                }
                impl ::core::fmt::Debug for JwtResult {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter<'_>,
                    ) -> ::core::fmt::Result {
                        match self {
                            JwtResult::Valid(e) => {
                                f.debug_tuple("JwtResult::Valid").field(e).finish()
                            }
                            JwtResult::Invalid(e) => {
                                f.debug_tuple("JwtResult::Invalid").field(e).finish()
                            }
                        }
                    }
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_validate_cabi<T: Guest>(arg0: *mut u8) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let l0 = *arg0.add(0).cast::<*mut u8>();
                    let l1 = *arg0
                        .add(::core::mem::size_of::<*const u8>())
                        .cast::<usize>();
                    let len2 = l1;
                    let bytes2 = _rt::Vec::from_raw_parts(l0.cast(), len2, len2);
                    let l3 = *arg0
                        .add(2 * ::core::mem::size_of::<*const u8>())
                        .cast::<*mut u8>();
                    let l4 = *arg0
                        .add(3 * ::core::mem::size_of::<*const u8>())
                        .cast::<usize>();
                    let len5 = l4;
                    let bytes5 = _rt::Vec::from_raw_parts(l3.cast(), len5, len5);
                    let l6 = *arg0
                        .add(4 * ::core::mem::size_of::<*const u8>())
                        .cast::<*mut u8>();
                    let l7 = *arg0
                        .add(5 * ::core::mem::size_of::<*const u8>())
                        .cast::<usize>();
                    let base11 = l6;
                    let len11 = l7;
                    let mut result11 = _rt::Vec::with_capacity(len11);
                    for i in 0..len11 {
                        let base = base11
                            .add(i * (2 * ::core::mem::size_of::<*const u8>()));
                        let e11 = {
                            let l8 = *base.add(0).cast::<*mut u8>();
                            let l9 = *base
                                .add(::core::mem::size_of::<*const u8>())
                                .cast::<usize>();
                            let len10 = l9;
                            let bytes10 = _rt::Vec::from_raw_parts(
                                l8.cast(),
                                len10,
                                len10,
                            );
                            _rt::string_lift(bytes10)
                        };
                        result11.push(e11);
                    }
                    _rt::cabi_dealloc(
                        base11,
                        len11 * (2 * ::core::mem::size_of::<*const u8>()),
                        ::core::mem::size_of::<*const u8>(),
                    );
                    let l12 = *arg0
                        .add(6 * ::core::mem::size_of::<*const u8>())
                        .cast::<*mut u8>();
                    let l13 = *arg0
                        .add(7 * ::core::mem::size_of::<*const u8>())
                        .cast::<usize>();
                    let len14 = l13;
                    let bytes14 = _rt::Vec::from_raw_parts(l12.cast(), len14, len14);
                    let l15 = i32::from(
                        *arg0.add(8 * ::core::mem::size_of::<*const u8>()).cast::<u8>(),
                    );
                    let l19 = i32::from(
                        *arg0.add(11 * ::core::mem::size_of::<*const u8>()).cast::<u8>(),
                    );
                    let l21 = i32::from(
                        *arg0
                            .add(2 + 11 * ::core::mem::size_of::<*const u8>())
                            .cast::<u8>(),
                    );
                    let l23 = i32::from(
                        *arg0.add(12 * ::core::mem::size_of::<*const u8>()).cast::<u8>(),
                    );
                    let result25 = T::validate(JwtRequest {
                        token: _rt::string_lift(bytes2),
                        expected_issuer: _rt::string_lift(bytes5),
                        expected_audiences: result11,
                        jwks_uri: _rt::string_lift(bytes14),
                        jwks_json: match l15 {
                            0 => None,
                            1 => {
                                let e = {
                                    let l16 = *arg0
                                        .add(9 * ::core::mem::size_of::<*const u8>())
                                        .cast::<*mut u8>();
                                    let l17 = *arg0
                                        .add(10 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    let len18 = l17;
                                    let bytes18 = _rt::Vec::from_raw_parts(
                                        l16.cast(),
                                        len18,
                                        len18,
                                    );
                                    _rt::string_lift(bytes18)
                                };
                                Some(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                        },
                        validate_exp: match l19 {
                            0 => None,
                            1 => {
                                let e = {
                                    let l20 = i32::from(
                                        *arg0
                                            .add(1 + 11 * ::core::mem::size_of::<*const u8>())
                                            .cast::<u8>(),
                                    );
                                    _rt::bool_lift(l20 as u8)
                                };
                                Some(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                        },
                        validate_nbf: match l21 {
                            0 => None,
                            1 => {
                                let e = {
                                    let l22 = i32::from(
                                        *arg0
                                            .add(3 + 11 * ::core::mem::size_of::<*const u8>())
                                            .cast::<u8>(),
                                    );
                                    _rt::bool_lift(l22 as u8)
                                };
                                Some(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                        },
                        clock_skew: match l23 {
                            0 => None,
                            1 => {
                                let e = {
                                    let l24 = *arg0
                                        .add(8 + 12 * ::core::mem::size_of::<*const u8>())
                                        .cast::<i64>();
                                    l24 as u64
                                };
                                Some(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                        },
                    });
                    _rt::cabi_dealloc(
                        arg0,
                        16 + 12 * ::core::mem::size_of::<*const u8>(),
                        8,
                    );
                    let ptr26 = (&raw mut _RET_AREA.0).cast::<u8>();
                    match result25 {
                        JwtResult::Valid(e) => {
                            *ptr26.add(0).cast::<u8>() = (0i32) as u8;
                            let JwtClaims {
                                sub: sub27,
                                iss: iss27,
                                aud: aud27,
                                exp: exp27,
                                iat: iat27,
                                nbf: nbf27,
                                jti: jti27,
                                scopes: scopes27,
                                client_id: client_id27,
                                additional_claims: additional_claims27,
                            } = e;
                            let vec28 = (sub27.into_bytes()).into_boxed_slice();
                            let ptr28 = vec28.as_ptr().cast::<u8>();
                            let len28 = vec28.len();
                            ::core::mem::forget(vec28);
                            *ptr26
                                .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>() = len28;
                            *ptr26.add(8).cast::<*mut u8>() = ptr28.cast_mut();
                            let vec29 = (iss27.into_bytes()).into_boxed_slice();
                            let ptr29 = vec29.as_ptr().cast::<u8>();
                            let len29 = vec29.len();
                            ::core::mem::forget(vec29);
                            *ptr26
                                .add(8 + 3 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>() = len29;
                            *ptr26
                                .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                .cast::<*mut u8>() = ptr29.cast_mut();
                            match aud27 {
                                Some(e) => {
                                    *ptr26
                                        .add(8 + 4 * ::core::mem::size_of::<*const u8>())
                                        .cast::<u8>() = (1i32) as u8;
                                    let vec31 = e;
                                    let len31 = vec31.len();
                                    let layout31 = _rt::alloc::Layout::from_size_align_unchecked(
                                        vec31.len() * (2 * ::core::mem::size_of::<*const u8>()),
                                        ::core::mem::size_of::<*const u8>(),
                                    );
                                    let result31 = if layout31.size() != 0 {
                                        let ptr = _rt::alloc::alloc(layout31).cast::<u8>();
                                        if ptr.is_null() {
                                            _rt::alloc::handle_alloc_error(layout31);
                                        }
                                        ptr
                                    } else {
                                        ::core::ptr::null_mut()
                                    };
                                    for (i, e) in vec31.into_iter().enumerate() {
                                        let base = result31
                                            .add(i * (2 * ::core::mem::size_of::<*const u8>()));
                                        {
                                            let vec30 = (e.into_bytes()).into_boxed_slice();
                                            let ptr30 = vec30.as_ptr().cast::<u8>();
                                            let len30 = vec30.len();
                                            ::core::mem::forget(vec30);
                                            *base
                                                .add(::core::mem::size_of::<*const u8>())
                                                .cast::<usize>() = len30;
                                            *base.add(0).cast::<*mut u8>() = ptr30.cast_mut();
                                        }
                                    }
                                    *ptr26
                                        .add(8 + 6 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len31;
                                    *ptr26
                                        .add(8 + 5 * ::core::mem::size_of::<*const u8>())
                                        .cast::<*mut u8>() = result31;
                                }
                                None => {
                                    *ptr26
                                        .add(8 + 4 * ::core::mem::size_of::<*const u8>())
                                        .cast::<u8>() = (0i32) as u8;
                                }
                            };
                            match exp27 {
                                Some(e) => {
                                    *ptr26
                                        .add(16 + 6 * ::core::mem::size_of::<*const u8>())
                                        .cast::<u8>() = (1i32) as u8;
                                    *ptr26
                                        .add(24 + 6 * ::core::mem::size_of::<*const u8>())
                                        .cast::<i64>() = _rt::as_i64(e);
                                }
                                None => {
                                    *ptr26
                                        .add(16 + 6 * ::core::mem::size_of::<*const u8>())
                                        .cast::<u8>() = (0i32) as u8;
                                }
                            };
                            match iat27 {
                                Some(e) => {
                                    *ptr26
                                        .add(32 + 6 * ::core::mem::size_of::<*const u8>())
                                        .cast::<u8>() = (1i32) as u8;
                                    *ptr26
                                        .add(40 + 6 * ::core::mem::size_of::<*const u8>())
                                        .cast::<i64>() = _rt::as_i64(e);
                                }
                                None => {
                                    *ptr26
                                        .add(32 + 6 * ::core::mem::size_of::<*const u8>())
                                        .cast::<u8>() = (0i32) as u8;
                                }
                            };
                            match nbf27 {
                                Some(e) => {
                                    *ptr26
                                        .add(48 + 6 * ::core::mem::size_of::<*const u8>())
                                        .cast::<u8>() = (1i32) as u8;
                                    *ptr26
                                        .add(56 + 6 * ::core::mem::size_of::<*const u8>())
                                        .cast::<i64>() = _rt::as_i64(e);
                                }
                                None => {
                                    *ptr26
                                        .add(48 + 6 * ::core::mem::size_of::<*const u8>())
                                        .cast::<u8>() = (0i32) as u8;
                                }
                            };
                            match jti27 {
                                Some(e) => {
                                    *ptr26
                                        .add(64 + 6 * ::core::mem::size_of::<*const u8>())
                                        .cast::<u8>() = (1i32) as u8;
                                    let vec32 = (e.into_bytes()).into_boxed_slice();
                                    let ptr32 = vec32.as_ptr().cast::<u8>();
                                    let len32 = vec32.len();
                                    ::core::mem::forget(vec32);
                                    *ptr26
                                        .add(64 + 8 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len32;
                                    *ptr26
                                        .add(64 + 7 * ::core::mem::size_of::<*const u8>())
                                        .cast::<*mut u8>() = ptr32.cast_mut();
                                }
                                None => {
                                    *ptr26
                                        .add(64 + 6 * ::core::mem::size_of::<*const u8>())
                                        .cast::<u8>() = (0i32) as u8;
                                }
                            };
                            let vec34 = scopes27;
                            let len34 = vec34.len();
                            let layout34 = _rt::alloc::Layout::from_size_align_unchecked(
                                vec34.len() * (2 * ::core::mem::size_of::<*const u8>()),
                                ::core::mem::size_of::<*const u8>(),
                            );
                            let result34 = if layout34.size() != 0 {
                                let ptr = _rt::alloc::alloc(layout34).cast::<u8>();
                                if ptr.is_null() {
                                    _rt::alloc::handle_alloc_error(layout34);
                                }
                                ptr
                            } else {
                                ::core::ptr::null_mut()
                            };
                            for (i, e) in vec34.into_iter().enumerate() {
                                let base = result34
                                    .add(i * (2 * ::core::mem::size_of::<*const u8>()));
                                {
                                    let vec33 = (e.into_bytes()).into_boxed_slice();
                                    let ptr33 = vec33.as_ptr().cast::<u8>();
                                    let len33 = vec33.len();
                                    ::core::mem::forget(vec33);
                                    *base
                                        .add(::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len33;
                                    *base.add(0).cast::<*mut u8>() = ptr33.cast_mut();
                                }
                            }
                            *ptr26
                                .add(64 + 10 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>() = len34;
                            *ptr26
                                .add(64 + 9 * ::core::mem::size_of::<*const u8>())
                                .cast::<*mut u8>() = result34;
                            match client_id27 {
                                Some(e) => {
                                    *ptr26
                                        .add(64 + 11 * ::core::mem::size_of::<*const u8>())
                                        .cast::<u8>() = (1i32) as u8;
                                    let vec35 = (e.into_bytes()).into_boxed_slice();
                                    let ptr35 = vec35.as_ptr().cast::<u8>();
                                    let len35 = vec35.len();
                                    ::core::mem::forget(vec35);
                                    *ptr26
                                        .add(64 + 13 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len35;
                                    *ptr26
                                        .add(64 + 12 * ::core::mem::size_of::<*const u8>())
                                        .cast::<*mut u8>() = ptr35.cast_mut();
                                }
                                None => {
                                    *ptr26
                                        .add(64 + 11 * ::core::mem::size_of::<*const u8>())
                                        .cast::<u8>() = (0i32) as u8;
                                }
                            };
                            let vec39 = additional_claims27;
                            let len39 = vec39.len();
                            let layout39 = _rt::alloc::Layout::from_size_align_unchecked(
                                vec39.len() * (4 * ::core::mem::size_of::<*const u8>()),
                                ::core::mem::size_of::<*const u8>(),
                            );
                            let result39 = if layout39.size() != 0 {
                                let ptr = _rt::alloc::alloc(layout39).cast::<u8>();
                                if ptr.is_null() {
                                    _rt::alloc::handle_alloc_error(layout39);
                                }
                                ptr
                            } else {
                                ::core::ptr::null_mut()
                            };
                            for (i, e) in vec39.into_iter().enumerate() {
                                let base = result39
                                    .add(i * (4 * ::core::mem::size_of::<*const u8>()));
                                {
                                    let (t36_0, t36_1) = e;
                                    let vec37 = (t36_0.into_bytes()).into_boxed_slice();
                                    let ptr37 = vec37.as_ptr().cast::<u8>();
                                    let len37 = vec37.len();
                                    ::core::mem::forget(vec37);
                                    *base
                                        .add(::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len37;
                                    *base.add(0).cast::<*mut u8>() = ptr37.cast_mut();
                                    let vec38 = (t36_1.into_bytes()).into_boxed_slice();
                                    let ptr38 = vec38.as_ptr().cast::<u8>();
                                    let len38 = vec38.len();
                                    ::core::mem::forget(vec38);
                                    *base
                                        .add(3 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len38;
                                    *base
                                        .add(2 * ::core::mem::size_of::<*const u8>())
                                        .cast::<*mut u8>() = ptr38.cast_mut();
                                }
                            }
                            *ptr26
                                .add(64 + 15 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>() = len39;
                            *ptr26
                                .add(64 + 14 * ::core::mem::size_of::<*const u8>())
                                .cast::<*mut u8>() = result39;
                        }
                        JwtResult::Invalid(e) => {
                            *ptr26.add(0).cast::<u8>() = (1i32) as u8;
                            *ptr26.add(8).cast::<u8>() = (e.clone() as i32) as u8;
                        }
                    }
                    ptr26
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn __post_return_validate<T: Guest>(arg0: *mut u8) {
                    let l0 = i32::from(*arg0.add(0).cast::<u8>());
                    match l0 {
                        0 => {
                            let l1 = *arg0.add(8).cast::<*mut u8>();
                            let l2 = *arg0
                                .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>();
                            _rt::cabi_dealloc(l1, l2, 1);
                            let l3 = *arg0
                                .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                .cast::<*mut u8>();
                            let l4 = *arg0
                                .add(8 + 3 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>();
                            _rt::cabi_dealloc(l3, l4, 1);
                            let l5 = i32::from(
                                *arg0
                                    .add(8 + 4 * ::core::mem::size_of::<*const u8>())
                                    .cast::<u8>(),
                            );
                            match l5 {
                                0 => {}
                                _ => {
                                    let l6 = *arg0
                                        .add(8 + 5 * ::core::mem::size_of::<*const u8>())
                                        .cast::<*mut u8>();
                                    let l7 = *arg0
                                        .add(8 + 6 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    let base10 = l6;
                                    let len10 = l7;
                                    for i in 0..len10 {
                                        let base = base10
                                            .add(i * (2 * ::core::mem::size_of::<*const u8>()));
                                        {
                                            let l8 = *base.add(0).cast::<*mut u8>();
                                            let l9 = *base
                                                .add(::core::mem::size_of::<*const u8>())
                                                .cast::<usize>();
                                            _rt::cabi_dealloc(l8, l9, 1);
                                        }
                                    }
                                    _rt::cabi_dealloc(
                                        base10,
                                        len10 * (2 * ::core::mem::size_of::<*const u8>()),
                                        ::core::mem::size_of::<*const u8>(),
                                    );
                                }
                            }
                            let l11 = i32::from(
                                *arg0
                                    .add(64 + 6 * ::core::mem::size_of::<*const u8>())
                                    .cast::<u8>(),
                            );
                            match l11 {
                                0 => {}
                                _ => {
                                    let l12 = *arg0
                                        .add(64 + 7 * ::core::mem::size_of::<*const u8>())
                                        .cast::<*mut u8>();
                                    let l13 = *arg0
                                        .add(64 + 8 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l12, l13, 1);
                                }
                            }
                            let l14 = *arg0
                                .add(64 + 9 * ::core::mem::size_of::<*const u8>())
                                .cast::<*mut u8>();
                            let l15 = *arg0
                                .add(64 + 10 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>();
                            let base18 = l14;
                            let len18 = l15;
                            for i in 0..len18 {
                                let base = base18
                                    .add(i * (2 * ::core::mem::size_of::<*const u8>()));
                                {
                                    let l16 = *base.add(0).cast::<*mut u8>();
                                    let l17 = *base
                                        .add(::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l16, l17, 1);
                                }
                            }
                            _rt::cabi_dealloc(
                                base18,
                                len18 * (2 * ::core::mem::size_of::<*const u8>()),
                                ::core::mem::size_of::<*const u8>(),
                            );
                            let l19 = i32::from(
                                *arg0
                                    .add(64 + 11 * ::core::mem::size_of::<*const u8>())
                                    .cast::<u8>(),
                            );
                            match l19 {
                                0 => {}
                                _ => {
                                    let l20 = *arg0
                                        .add(64 + 12 * ::core::mem::size_of::<*const u8>())
                                        .cast::<*mut u8>();
                                    let l21 = *arg0
                                        .add(64 + 13 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l20, l21, 1);
                                }
                            }
                            let l22 = *arg0
                                .add(64 + 14 * ::core::mem::size_of::<*const u8>())
                                .cast::<*mut u8>();
                            let l23 = *arg0
                                .add(64 + 15 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>();
                            let base28 = l22;
                            let len28 = l23;
                            for i in 0..len28 {
                                let base = base28
                                    .add(i * (4 * ::core::mem::size_of::<*const u8>()));
                                {
                                    let l24 = *base.add(0).cast::<*mut u8>();
                                    let l25 = *base
                                        .add(::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l24, l25, 1);
                                    let l26 = *base
                                        .add(2 * ::core::mem::size_of::<*const u8>())
                                        .cast::<*mut u8>();
                                    let l27 = *base
                                        .add(3 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l26, l27, 1);
                                }
                            }
                            _rt::cabi_dealloc(
                                base28,
                                len28 * (4 * ::core::mem::size_of::<*const u8>()),
                                ::core::mem::size_of::<*const u8>(),
                            );
                        }
                        _ => {}
                    }
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_fetch_jwks_cabi<T: Guest>(
                    arg0: *mut u8,
                    arg1: usize,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let len0 = arg1;
                    let bytes0 = _rt::Vec::from_raw_parts(arg0.cast(), len0, len0);
                    let result1 = T::fetch_jwks(_rt::string_lift(bytes0));
                    let ptr2 = (&raw mut _RET_AREA.0).cast::<u8>();
                    match result1 {
                        Ok(e) => {
                            *ptr2.add(0).cast::<u8>() = (0i32) as u8;
                            let vec3 = (e.into_bytes()).into_boxed_slice();
                            let ptr3 = vec3.as_ptr().cast::<u8>();
                            let len3 = vec3.len();
                            ::core::mem::forget(vec3);
                            *ptr2
                                .add(2 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>() = len3;
                            *ptr2
                                .add(::core::mem::size_of::<*const u8>())
                                .cast::<*mut u8>() = ptr3.cast_mut();
                        }
                        Err(e) => {
                            *ptr2.add(0).cast::<u8>() = (1i32) as u8;
                            let vec4 = (e.into_bytes()).into_boxed_slice();
                            let ptr4 = vec4.as_ptr().cast::<u8>();
                            let len4 = vec4.len();
                            ::core::mem::forget(vec4);
                            *ptr2
                                .add(2 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>() = len4;
                            *ptr2
                                .add(::core::mem::size_of::<*const u8>())
                                .cast::<*mut u8>() = ptr4.cast_mut();
                        }
                    };
                    ptr2
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn __post_return_fetch_jwks<T: Guest>(arg0: *mut u8) {
                    let l0 = i32::from(*arg0.add(0).cast::<u8>());
                    match l0 {
                        0 => {
                            let l1 = *arg0
                                .add(::core::mem::size_of::<*const u8>())
                                .cast::<*mut u8>();
                            let l2 = *arg0
                                .add(2 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>();
                            _rt::cabi_dealloc(l1, l2, 1);
                        }
                        _ => {
                            let l3 = *arg0
                                .add(::core::mem::size_of::<*const u8>())
                                .cast::<*mut u8>();
                            let l4 = *arg0
                                .add(2 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>();
                            _rt::cabi_dealloc(l3, l4, 1);
                        }
                    }
                }
                pub trait Guest {
                    /// Validate a JWT token
                    fn validate(request: JwtRequest) -> JwtResult;
                    /// Fetch and cache JWKS from a URI
                    fn fetch_jwks(uri: _rt::String) -> Result<_rt::String, _rt::String>;
                }
                #[doc(hidden)]
                macro_rules! __export_fastertools_mcp_jwt_validator_0_1_16_cabi {
                    ($ty:ident with_types_in $($path_to_types:tt)*) => {
                        const _ : () = { #[unsafe (export_name =
                        "fastertools:mcp/jwt-validator@0.1.16#validate")] unsafe extern
                        "C" fn export_validate(arg0 : * mut u8,) -> * mut u8 { unsafe {
                        $($path_to_types)*:: _export_validate_cabi::<$ty > (arg0) } }
                        #[unsafe (export_name =
                        "cabi_post_fastertools:mcp/jwt-validator@0.1.16#validate")]
                        unsafe extern "C" fn _post_return_validate(arg0 : * mut u8,) {
                        unsafe { $($path_to_types)*:: __post_return_validate::<$ty >
                        (arg0) } } #[unsafe (export_name =
                        "fastertools:mcp/jwt-validator@0.1.16#fetch-jwks")] unsafe extern
                        "C" fn export_fetch_jwks(arg0 : * mut u8, arg1 : usize,) -> * mut
                        u8 { unsafe { $($path_to_types)*:: _export_fetch_jwks_cabi::<$ty
                        > (arg0, arg1) } } #[unsafe (export_name =
                        "cabi_post_fastertools:mcp/jwt-validator@0.1.16#fetch-jwks")]
                        unsafe extern "C" fn _post_return_fetch_jwks(arg0 : * mut u8,) {
                        unsafe { $($path_to_types)*:: __post_return_fetch_jwks::<$ty >
                        (arg0) } } };
                    };
                }
                #[doc(hidden)]
                pub(crate) use __export_fastertools_mcp_jwt_validator_0_1_16_cabi;
                #[repr(align(8))]
                struct _RetArea(
                    [::core::mem::MaybeUninit<
                        u8,
                    >; 64 + 16 * ::core::mem::size_of::<*const u8>()],
                );
                static mut _RET_AREA: _RetArea = _RetArea(
                    [::core::mem::MaybeUninit::uninit(); 64
                        + 16 * ::core::mem::size_of::<*const u8>()],
                );
            }
            /// Policy evaluation interface for OPA/Rego policies
            #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
            pub mod policy_engine {
                #[used]
                #[doc(hidden)]
                static __FORCE_SECTION_REF: fn() = super::super::super::super::__link_custom_section_describing_imports;
                use super::super::super::super::_rt;
                pub type JsonValue = super::super::super::super::fastertools::mcp::types::JsonValue;
                /// Policy evaluation request
                #[derive(Clone, serde::Deserialize, serde::Serialize)]
                pub struct PolicyRequest {
                    /// Rego policy source code
                    pub policy: _rt::String,
                    /// Optional external data for policy evaluation
                    pub data: Option<JsonValue>,
                    /// Input data for policy evaluation (token claims, request context, etc.)
                    pub input: JsonValue,
                    /// Query to evaluate (default: data.mcp.authorization.allow)
                    pub query: Option<_rt::String>,
                }
                impl ::core::fmt::Debug for PolicyRequest {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter<'_>,
                    ) -> ::core::fmt::Result {
                        f.debug_struct("PolicyRequest")
                            .field("policy", &self.policy)
                            .field("data", &self.data)
                            .field("input", &self.input)
                            .field("query", &self.query)
                            .finish()
                    }
                }
                /// Policy evaluation result
                #[derive(Clone, serde::Deserialize, serde::Serialize)]
                pub enum PolicyResult {
                    /// Policy allowed the request
                    Allow,
                    /// Policy denied the request with reason
                    Deny(_rt::String),
                    /// Policy evaluation error
                    Error(_rt::String),
                }
                impl ::core::fmt::Debug for PolicyResult {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter<'_>,
                    ) -> ::core::fmt::Result {
                        match self {
                            PolicyResult::Allow => {
                                f.debug_tuple("PolicyResult::Allow").finish()
                            }
                            PolicyResult::Deny(e) => {
                                f.debug_tuple("PolicyResult::Deny").field(e).finish()
                            }
                            PolicyResult::Error(e) => {
                                f.debug_tuple("PolicyResult::Error").field(e).finish()
                            }
                        }
                    }
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_evaluate_cabi<T: Guest>(
                    arg0: *mut u8,
                    arg1: usize,
                    arg2: i32,
                    arg3: *mut u8,
                    arg4: usize,
                    arg5: *mut u8,
                    arg6: usize,
                    arg7: i32,
                    arg8: *mut u8,
                    arg9: usize,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let len0 = arg1;
                    let bytes0 = _rt::Vec::from_raw_parts(arg0.cast(), len0, len0);
                    let len2 = arg6;
                    let bytes2 = _rt::Vec::from_raw_parts(arg5.cast(), len2, len2);
                    let result4 = T::evaluate(PolicyRequest {
                        policy: _rt::string_lift(bytes0),
                        data: match arg2 {
                            0 => None,
                            1 => {
                                let e = {
                                    let len1 = arg4;
                                    let bytes1 = _rt::Vec::from_raw_parts(
                                        arg3.cast(),
                                        len1,
                                        len1,
                                    );
                                    _rt::string_lift(bytes1)
                                };
                                Some(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                        },
                        input: _rt::string_lift(bytes2),
                        query: match arg7 {
                            0 => None,
                            1 => {
                                let e = {
                                    let len3 = arg9;
                                    let bytes3 = _rt::Vec::from_raw_parts(
                                        arg8.cast(),
                                        len3,
                                        len3,
                                    );
                                    _rt::string_lift(bytes3)
                                };
                                Some(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                        },
                    });
                    let ptr5 = (&raw mut _RET_AREA.0).cast::<u8>();
                    match result4 {
                        PolicyResult::Allow => {
                            *ptr5.add(0).cast::<u8>() = (0i32) as u8;
                        }
                        PolicyResult::Deny(e) => {
                            *ptr5.add(0).cast::<u8>() = (1i32) as u8;
                            let vec6 = (e.into_bytes()).into_boxed_slice();
                            let ptr6 = vec6.as_ptr().cast::<u8>();
                            let len6 = vec6.len();
                            ::core::mem::forget(vec6);
                            *ptr5
                                .add(2 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>() = len6;
                            *ptr5
                                .add(::core::mem::size_of::<*const u8>())
                                .cast::<*mut u8>() = ptr6.cast_mut();
                        }
                        PolicyResult::Error(e) => {
                            *ptr5.add(0).cast::<u8>() = (2i32) as u8;
                            let vec7 = (e.into_bytes()).into_boxed_slice();
                            let ptr7 = vec7.as_ptr().cast::<u8>();
                            let len7 = vec7.len();
                            ::core::mem::forget(vec7);
                            *ptr5
                                .add(2 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>() = len7;
                            *ptr5
                                .add(::core::mem::size_of::<*const u8>())
                                .cast::<*mut u8>() = ptr7.cast_mut();
                        }
                    }
                    ptr5
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn __post_return_evaluate<T: Guest>(arg0: *mut u8) {
                    let l0 = i32::from(*arg0.add(0).cast::<u8>());
                    match l0 {
                        0 => {}
                        1 => {
                            let l1 = *arg0
                                .add(::core::mem::size_of::<*const u8>())
                                .cast::<*mut u8>();
                            let l2 = *arg0
                                .add(2 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>();
                            _rt::cabi_dealloc(l1, l2, 1);
                        }
                        _ => {
                            let l3 = *arg0
                                .add(::core::mem::size_of::<*const u8>())
                                .cast::<*mut u8>();
                            let l4 = *arg0
                                .add(2 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>();
                            _rt::cabi_dealloc(l3, l4, 1);
                        }
                    }
                }
                pub trait Guest {
                    /// Evaluate a Rego policy with input and optional data
                    fn evaluate(request: PolicyRequest) -> PolicyResult;
                }
                #[doc(hidden)]
                macro_rules! __export_fastertools_mcp_policy_engine_0_1_16_cabi {
                    ($ty:ident with_types_in $($path_to_types:tt)*) => {
                        const _ : () = { #[unsafe (export_name =
                        "fastertools:mcp/policy-engine@0.1.16#evaluate")] unsafe extern
                        "C" fn export_evaluate(arg0 : * mut u8, arg1 : usize, arg2 : i32,
                        arg3 : * mut u8, arg4 : usize, arg5 : * mut u8, arg6 : usize,
                        arg7 : i32, arg8 : * mut u8, arg9 : usize,) -> * mut u8 { unsafe
                        { $($path_to_types)*:: _export_evaluate_cabi::<$ty > (arg0, arg1,
                        arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9) } } #[unsafe
                        (export_name =
                        "cabi_post_fastertools:mcp/policy-engine@0.1.16#evaluate")]
                        unsafe extern "C" fn _post_return_evaluate(arg0 : * mut u8,) {
                        unsafe { $($path_to_types)*:: __post_return_evaluate::<$ty >
                        (arg0) } } };
                    };
                }
                #[doc(hidden)]
                pub(crate) use __export_fastertools_mcp_policy_engine_0_1_16_cabi;
                #[cfg_attr(target_pointer_width = "64", repr(align(8)))]
                #[cfg_attr(target_pointer_width = "32", repr(align(4)))]
                struct _RetArea(
                    [::core::mem::MaybeUninit<
                        u8,
                    >; 3 * ::core::mem::size_of::<*const u8>()],
                );
                static mut _RET_AREA: _RetArea = _RetArea(
                    [::core::mem::MaybeUninit::uninit(); 3
                        * ::core::mem::size_of::<*const u8>()],
                );
            }
            /// OAuth 2.0 discovery endpoints per RFC 8414 and RFC 9728
            #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
            pub mod oauth_discovery {
                #[used]
                #[doc(hidden)]
                static __FORCE_SECTION_REF: fn() = super::super::super::super::__link_custom_section_describing_imports;
                use super::super::super::super::_rt;
                /// OAuth 2.0 Protected Resource Metadata per RFC 9728
                #[derive(Clone, serde::Deserialize, serde::Serialize)]
                pub struct ResourceMetadata {
                    /// Resource identifier (canonical URI of the MCP server)
                    pub resource_url: _rt::String,
                    /// List of authorization server URLs that can issue tokens for this resource
                    pub authorization_servers: _rt::Vec<_rt::String>,
                    /// Scopes supported by this resource
                    pub scopes_supported: Option<_rt::Vec<_rt::String>>,
                    /// Bearer token types supported
                    pub bearer_methods_supported: Option<_rt::Vec<_rt::String>>,
                    /// Resource-specific metadata
                    pub resource_documentation: Option<_rt::String>,
                }
                impl ::core::fmt::Debug for ResourceMetadata {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter<'_>,
                    ) -> ::core::fmt::Result {
                        f.debug_struct("ResourceMetadata")
                            .field("resource-url", &self.resource_url)
                            .field("authorization-servers", &self.authorization_servers)
                            .field("scopes-supported", &self.scopes_supported)
                            .field(
                                "bearer-methods-supported",
                                &self.bearer_methods_supported,
                            )
                            .field(
                                "resource-documentation",
                                &self.resource_documentation,
                            )
                            .finish()
                    }
                }
                /// OAuth 2.0 Authorization Server Metadata per RFC 8414
                #[derive(Clone, serde::Deserialize, serde::Serialize)]
                pub struct ServerMetadata {
                    /// Authorization server identifier
                    pub issuer: _rt::String,
                    /// Authorization endpoint URL
                    pub authorization_endpoint: _rt::String,
                    /// Token endpoint URL
                    pub token_endpoint: _rt::String,
                    /// JWKS URI for key discovery
                    pub jwks_uri: _rt::String,
                    /// Supported response types
                    pub response_types_supported: _rt::Vec<_rt::String>,
                    /// Supported grant types
                    pub grant_types_supported: _rt::Vec<_rt::String>,
                    /// Supported code challenge methods for PKCE
                    pub code_challenge_methods_supported: _rt::Vec<_rt::String>,
                    /// Supported scopes
                    pub scopes_supported: Option<_rt::Vec<_rt::String>>,
                    /// Token endpoint auth methods supported
                    pub token_endpoint_auth_methods_supported: Option<
                        _rt::Vec<_rt::String>,
                    >,
                    /// Service documentation URL
                    pub service_documentation: Option<_rt::String>,
                    /// Registration endpoint for dynamic client registration
                    pub registration_endpoint: Option<_rt::String>,
                }
                impl ::core::fmt::Debug for ServerMetadata {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter<'_>,
                    ) -> ::core::fmt::Result {
                        f.debug_struct("ServerMetadata")
                            .field("issuer", &self.issuer)
                            .field(
                                "authorization-endpoint",
                                &self.authorization_endpoint,
                            )
                            .field("token-endpoint", &self.token_endpoint)
                            .field("jwks-uri", &self.jwks_uri)
                            .field(
                                "response-types-supported",
                                &self.response_types_supported,
                            )
                            .field("grant-types-supported", &self.grant_types_supported)
                            .field(
                                "code-challenge-methods-supported",
                                &self.code_challenge_methods_supported,
                            )
                            .field("scopes-supported", &self.scopes_supported)
                            .field(
                                "token-endpoint-auth-methods-supported",
                                &self.token_endpoint_auth_methods_supported,
                            )
                            .field("service-documentation", &self.service_documentation)
                            .field("registration-endpoint", &self.registration_endpoint)
                            .finish()
                    }
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_get_resource_metadata_cabi<T: Guest>() -> *mut u8 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let result0 = T::get_resource_metadata();
                    let ptr1 = (&raw mut _RET_AREA.0).cast::<u8>();
                    let ResourceMetadata {
                        resource_url: resource_url2,
                        authorization_servers: authorization_servers2,
                        scopes_supported: scopes_supported2,
                        bearer_methods_supported: bearer_methods_supported2,
                        resource_documentation: resource_documentation2,
                    } = result0;
                    let vec3 = (resource_url2.into_bytes()).into_boxed_slice();
                    let ptr3 = vec3.as_ptr().cast::<u8>();
                    let len3 = vec3.len();
                    ::core::mem::forget(vec3);
                    *ptr1.add(::core::mem::size_of::<*const u8>()).cast::<usize>() = len3;
                    *ptr1.add(0).cast::<*mut u8>() = ptr3.cast_mut();
                    let vec5 = authorization_servers2;
                    let len5 = vec5.len();
                    let layout5 = _rt::alloc::Layout::from_size_align_unchecked(
                        vec5.len() * (2 * ::core::mem::size_of::<*const u8>()),
                        ::core::mem::size_of::<*const u8>(),
                    );
                    let result5 = if layout5.size() != 0 {
                        let ptr = _rt::alloc::alloc(layout5).cast::<u8>();
                        if ptr.is_null() {
                            _rt::alloc::handle_alloc_error(layout5);
                        }
                        ptr
                    } else {
                        ::core::ptr::null_mut()
                    };
                    for (i, e) in vec5.into_iter().enumerate() {
                        let base = result5
                            .add(i * (2 * ::core::mem::size_of::<*const u8>()));
                        {
                            let vec4 = (e.into_bytes()).into_boxed_slice();
                            let ptr4 = vec4.as_ptr().cast::<u8>();
                            let len4 = vec4.len();
                            ::core::mem::forget(vec4);
                            *base
                                .add(::core::mem::size_of::<*const u8>())
                                .cast::<usize>() = len4;
                            *base.add(0).cast::<*mut u8>() = ptr4.cast_mut();
                        }
                    }
                    *ptr1.add(3 * ::core::mem::size_of::<*const u8>()).cast::<usize>() = len5;
                    *ptr1
                        .add(2 * ::core::mem::size_of::<*const u8>())
                        .cast::<*mut u8>() = result5;
                    match scopes_supported2 {
                        Some(e) => {
                            *ptr1
                                .add(4 * ::core::mem::size_of::<*const u8>())
                                .cast::<u8>() = (1i32) as u8;
                            let vec7 = e;
                            let len7 = vec7.len();
                            let layout7 = _rt::alloc::Layout::from_size_align_unchecked(
                                vec7.len() * (2 * ::core::mem::size_of::<*const u8>()),
                                ::core::mem::size_of::<*const u8>(),
                            );
                            let result7 = if layout7.size() != 0 {
                                let ptr = _rt::alloc::alloc(layout7).cast::<u8>();
                                if ptr.is_null() {
                                    _rt::alloc::handle_alloc_error(layout7);
                                }
                                ptr
                            } else {
                                ::core::ptr::null_mut()
                            };
                            for (i, e) in vec7.into_iter().enumerate() {
                                let base = result7
                                    .add(i * (2 * ::core::mem::size_of::<*const u8>()));
                                {
                                    let vec6 = (e.into_bytes()).into_boxed_slice();
                                    let ptr6 = vec6.as_ptr().cast::<u8>();
                                    let len6 = vec6.len();
                                    ::core::mem::forget(vec6);
                                    *base
                                        .add(::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len6;
                                    *base.add(0).cast::<*mut u8>() = ptr6.cast_mut();
                                }
                            }
                            *ptr1
                                .add(6 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>() = len7;
                            *ptr1
                                .add(5 * ::core::mem::size_of::<*const u8>())
                                .cast::<*mut u8>() = result7;
                        }
                        None => {
                            *ptr1
                                .add(4 * ::core::mem::size_of::<*const u8>())
                                .cast::<u8>() = (0i32) as u8;
                        }
                    };
                    match bearer_methods_supported2 {
                        Some(e) => {
                            *ptr1
                                .add(7 * ::core::mem::size_of::<*const u8>())
                                .cast::<u8>() = (1i32) as u8;
                            let vec9 = e;
                            let len9 = vec9.len();
                            let layout9 = _rt::alloc::Layout::from_size_align_unchecked(
                                vec9.len() * (2 * ::core::mem::size_of::<*const u8>()),
                                ::core::mem::size_of::<*const u8>(),
                            );
                            let result9 = if layout9.size() != 0 {
                                let ptr = _rt::alloc::alloc(layout9).cast::<u8>();
                                if ptr.is_null() {
                                    _rt::alloc::handle_alloc_error(layout9);
                                }
                                ptr
                            } else {
                                ::core::ptr::null_mut()
                            };
                            for (i, e) in vec9.into_iter().enumerate() {
                                let base = result9
                                    .add(i * (2 * ::core::mem::size_of::<*const u8>()));
                                {
                                    let vec8 = (e.into_bytes()).into_boxed_slice();
                                    let ptr8 = vec8.as_ptr().cast::<u8>();
                                    let len8 = vec8.len();
                                    ::core::mem::forget(vec8);
                                    *base
                                        .add(::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len8;
                                    *base.add(0).cast::<*mut u8>() = ptr8.cast_mut();
                                }
                            }
                            *ptr1
                                .add(9 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>() = len9;
                            *ptr1
                                .add(8 * ::core::mem::size_of::<*const u8>())
                                .cast::<*mut u8>() = result9;
                        }
                        None => {
                            *ptr1
                                .add(7 * ::core::mem::size_of::<*const u8>())
                                .cast::<u8>() = (0i32) as u8;
                        }
                    };
                    match resource_documentation2 {
                        Some(e) => {
                            *ptr1
                                .add(10 * ::core::mem::size_of::<*const u8>())
                                .cast::<u8>() = (1i32) as u8;
                            let vec10 = (e.into_bytes()).into_boxed_slice();
                            let ptr10 = vec10.as_ptr().cast::<u8>();
                            let len10 = vec10.len();
                            ::core::mem::forget(vec10);
                            *ptr1
                                .add(12 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>() = len10;
                            *ptr1
                                .add(11 * ::core::mem::size_of::<*const u8>())
                                .cast::<*mut u8>() = ptr10.cast_mut();
                        }
                        None => {
                            *ptr1
                                .add(10 * ::core::mem::size_of::<*const u8>())
                                .cast::<u8>() = (0i32) as u8;
                        }
                    };
                    ptr1
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn __post_return_get_resource_metadata<T: Guest>(
                    arg0: *mut u8,
                ) {
                    let l0 = *arg0.add(0).cast::<*mut u8>();
                    let l1 = *arg0
                        .add(::core::mem::size_of::<*const u8>())
                        .cast::<usize>();
                    _rt::cabi_dealloc(l0, l1, 1);
                    let l2 = *arg0
                        .add(2 * ::core::mem::size_of::<*const u8>())
                        .cast::<*mut u8>();
                    let l3 = *arg0
                        .add(3 * ::core::mem::size_of::<*const u8>())
                        .cast::<usize>();
                    let base6 = l2;
                    let len6 = l3;
                    for i in 0..len6 {
                        let base = base6
                            .add(i * (2 * ::core::mem::size_of::<*const u8>()));
                        {
                            let l4 = *base.add(0).cast::<*mut u8>();
                            let l5 = *base
                                .add(::core::mem::size_of::<*const u8>())
                                .cast::<usize>();
                            _rt::cabi_dealloc(l4, l5, 1);
                        }
                    }
                    _rt::cabi_dealloc(
                        base6,
                        len6 * (2 * ::core::mem::size_of::<*const u8>()),
                        ::core::mem::size_of::<*const u8>(),
                    );
                    let l7 = i32::from(
                        *arg0.add(4 * ::core::mem::size_of::<*const u8>()).cast::<u8>(),
                    );
                    match l7 {
                        0 => {}
                        _ => {
                            let l8 = *arg0
                                .add(5 * ::core::mem::size_of::<*const u8>())
                                .cast::<*mut u8>();
                            let l9 = *arg0
                                .add(6 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>();
                            let base12 = l8;
                            let len12 = l9;
                            for i in 0..len12 {
                                let base = base12
                                    .add(i * (2 * ::core::mem::size_of::<*const u8>()));
                                {
                                    let l10 = *base.add(0).cast::<*mut u8>();
                                    let l11 = *base
                                        .add(::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l10, l11, 1);
                                }
                            }
                            _rt::cabi_dealloc(
                                base12,
                                len12 * (2 * ::core::mem::size_of::<*const u8>()),
                                ::core::mem::size_of::<*const u8>(),
                            );
                        }
                    }
                    let l13 = i32::from(
                        *arg0.add(7 * ::core::mem::size_of::<*const u8>()).cast::<u8>(),
                    );
                    match l13 {
                        0 => {}
                        _ => {
                            let l14 = *arg0
                                .add(8 * ::core::mem::size_of::<*const u8>())
                                .cast::<*mut u8>();
                            let l15 = *arg0
                                .add(9 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>();
                            let base18 = l14;
                            let len18 = l15;
                            for i in 0..len18 {
                                let base = base18
                                    .add(i * (2 * ::core::mem::size_of::<*const u8>()));
                                {
                                    let l16 = *base.add(0).cast::<*mut u8>();
                                    let l17 = *base
                                        .add(::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l16, l17, 1);
                                }
                            }
                            _rt::cabi_dealloc(
                                base18,
                                len18 * (2 * ::core::mem::size_of::<*const u8>()),
                                ::core::mem::size_of::<*const u8>(),
                            );
                        }
                    }
                    let l19 = i32::from(
                        *arg0.add(10 * ::core::mem::size_of::<*const u8>()).cast::<u8>(),
                    );
                    match l19 {
                        0 => {}
                        _ => {
                            let l20 = *arg0
                                .add(11 * ::core::mem::size_of::<*const u8>())
                                .cast::<*mut u8>();
                            let l21 = *arg0
                                .add(12 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>();
                            _rt::cabi_dealloc(l20, l21, 1);
                        }
                    }
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_get_server_metadata_cabi<T: Guest>() -> *mut u8 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let result0 = T::get_server_metadata();
                    let ptr1 = (&raw mut _RET_AREA.0).cast::<u8>();
                    let ServerMetadata {
                        issuer: issuer2,
                        authorization_endpoint: authorization_endpoint2,
                        token_endpoint: token_endpoint2,
                        jwks_uri: jwks_uri2,
                        response_types_supported: response_types_supported2,
                        grant_types_supported: grant_types_supported2,
                        code_challenge_methods_supported: code_challenge_methods_supported2,
                        scopes_supported: scopes_supported2,
                        token_endpoint_auth_methods_supported: token_endpoint_auth_methods_supported2,
                        service_documentation: service_documentation2,
                        registration_endpoint: registration_endpoint2,
                    } = result0;
                    let vec3 = (issuer2.into_bytes()).into_boxed_slice();
                    let ptr3 = vec3.as_ptr().cast::<u8>();
                    let len3 = vec3.len();
                    ::core::mem::forget(vec3);
                    *ptr1.add(::core::mem::size_of::<*const u8>()).cast::<usize>() = len3;
                    *ptr1.add(0).cast::<*mut u8>() = ptr3.cast_mut();
                    let vec4 = (authorization_endpoint2.into_bytes()).into_boxed_slice();
                    let ptr4 = vec4.as_ptr().cast::<u8>();
                    let len4 = vec4.len();
                    ::core::mem::forget(vec4);
                    *ptr1.add(3 * ::core::mem::size_of::<*const u8>()).cast::<usize>() = len4;
                    *ptr1
                        .add(2 * ::core::mem::size_of::<*const u8>())
                        .cast::<*mut u8>() = ptr4.cast_mut();
                    let vec5 = (token_endpoint2.into_bytes()).into_boxed_slice();
                    let ptr5 = vec5.as_ptr().cast::<u8>();
                    let len5 = vec5.len();
                    ::core::mem::forget(vec5);
                    *ptr1.add(5 * ::core::mem::size_of::<*const u8>()).cast::<usize>() = len5;
                    *ptr1
                        .add(4 * ::core::mem::size_of::<*const u8>())
                        .cast::<*mut u8>() = ptr5.cast_mut();
                    let vec6 = (jwks_uri2.into_bytes()).into_boxed_slice();
                    let ptr6 = vec6.as_ptr().cast::<u8>();
                    let len6 = vec6.len();
                    ::core::mem::forget(vec6);
                    *ptr1.add(7 * ::core::mem::size_of::<*const u8>()).cast::<usize>() = len6;
                    *ptr1
                        .add(6 * ::core::mem::size_of::<*const u8>())
                        .cast::<*mut u8>() = ptr6.cast_mut();
                    let vec8 = response_types_supported2;
                    let len8 = vec8.len();
                    let layout8 = _rt::alloc::Layout::from_size_align_unchecked(
                        vec8.len() * (2 * ::core::mem::size_of::<*const u8>()),
                        ::core::mem::size_of::<*const u8>(),
                    );
                    let result8 = if layout8.size() != 0 {
                        let ptr = _rt::alloc::alloc(layout8).cast::<u8>();
                        if ptr.is_null() {
                            _rt::alloc::handle_alloc_error(layout8);
                        }
                        ptr
                    } else {
                        ::core::ptr::null_mut()
                    };
                    for (i, e) in vec8.into_iter().enumerate() {
                        let base = result8
                            .add(i * (2 * ::core::mem::size_of::<*const u8>()));
                        {
                            let vec7 = (e.into_bytes()).into_boxed_slice();
                            let ptr7 = vec7.as_ptr().cast::<u8>();
                            let len7 = vec7.len();
                            ::core::mem::forget(vec7);
                            *base
                                .add(::core::mem::size_of::<*const u8>())
                                .cast::<usize>() = len7;
                            *base.add(0).cast::<*mut u8>() = ptr7.cast_mut();
                        }
                    }
                    *ptr1.add(9 * ::core::mem::size_of::<*const u8>()).cast::<usize>() = len8;
                    *ptr1
                        .add(8 * ::core::mem::size_of::<*const u8>())
                        .cast::<*mut u8>() = result8;
                    let vec10 = grant_types_supported2;
                    let len10 = vec10.len();
                    let layout10 = _rt::alloc::Layout::from_size_align_unchecked(
                        vec10.len() * (2 * ::core::mem::size_of::<*const u8>()),
                        ::core::mem::size_of::<*const u8>(),
                    );
                    let result10 = if layout10.size() != 0 {
                        let ptr = _rt::alloc::alloc(layout10).cast::<u8>();
                        if ptr.is_null() {
                            _rt::alloc::handle_alloc_error(layout10);
                        }
                        ptr
                    } else {
                        ::core::ptr::null_mut()
                    };
                    for (i, e) in vec10.into_iter().enumerate() {
                        let base = result10
                            .add(i * (2 * ::core::mem::size_of::<*const u8>()));
                        {
                            let vec9 = (e.into_bytes()).into_boxed_slice();
                            let ptr9 = vec9.as_ptr().cast::<u8>();
                            let len9 = vec9.len();
                            ::core::mem::forget(vec9);
                            *base
                                .add(::core::mem::size_of::<*const u8>())
                                .cast::<usize>() = len9;
                            *base.add(0).cast::<*mut u8>() = ptr9.cast_mut();
                        }
                    }
                    *ptr1
                        .add(11 * ::core::mem::size_of::<*const u8>())
                        .cast::<usize>() = len10;
                    *ptr1
                        .add(10 * ::core::mem::size_of::<*const u8>())
                        .cast::<*mut u8>() = result10;
                    let vec12 = code_challenge_methods_supported2;
                    let len12 = vec12.len();
                    let layout12 = _rt::alloc::Layout::from_size_align_unchecked(
                        vec12.len() * (2 * ::core::mem::size_of::<*const u8>()),
                        ::core::mem::size_of::<*const u8>(),
                    );
                    let result12 = if layout12.size() != 0 {
                        let ptr = _rt::alloc::alloc(layout12).cast::<u8>();
                        if ptr.is_null() {
                            _rt::alloc::handle_alloc_error(layout12);
                        }
                        ptr
                    } else {
                        ::core::ptr::null_mut()
                    };
                    for (i, e) in vec12.into_iter().enumerate() {
                        let base = result12
                            .add(i * (2 * ::core::mem::size_of::<*const u8>()));
                        {
                            let vec11 = (e.into_bytes()).into_boxed_slice();
                            let ptr11 = vec11.as_ptr().cast::<u8>();
                            let len11 = vec11.len();
                            ::core::mem::forget(vec11);
                            *base
                                .add(::core::mem::size_of::<*const u8>())
                                .cast::<usize>() = len11;
                            *base.add(0).cast::<*mut u8>() = ptr11.cast_mut();
                        }
                    }
                    *ptr1
                        .add(13 * ::core::mem::size_of::<*const u8>())
                        .cast::<usize>() = len12;
                    *ptr1
                        .add(12 * ::core::mem::size_of::<*const u8>())
                        .cast::<*mut u8>() = result12;
                    match scopes_supported2 {
                        Some(e) => {
                            *ptr1
                                .add(14 * ::core::mem::size_of::<*const u8>())
                                .cast::<u8>() = (1i32) as u8;
                            let vec14 = e;
                            let len14 = vec14.len();
                            let layout14 = _rt::alloc::Layout::from_size_align_unchecked(
                                vec14.len() * (2 * ::core::mem::size_of::<*const u8>()),
                                ::core::mem::size_of::<*const u8>(),
                            );
                            let result14 = if layout14.size() != 0 {
                                let ptr = _rt::alloc::alloc(layout14).cast::<u8>();
                                if ptr.is_null() {
                                    _rt::alloc::handle_alloc_error(layout14);
                                }
                                ptr
                            } else {
                                ::core::ptr::null_mut()
                            };
                            for (i, e) in vec14.into_iter().enumerate() {
                                let base = result14
                                    .add(i * (2 * ::core::mem::size_of::<*const u8>()));
                                {
                                    let vec13 = (e.into_bytes()).into_boxed_slice();
                                    let ptr13 = vec13.as_ptr().cast::<u8>();
                                    let len13 = vec13.len();
                                    ::core::mem::forget(vec13);
                                    *base
                                        .add(::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len13;
                                    *base.add(0).cast::<*mut u8>() = ptr13.cast_mut();
                                }
                            }
                            *ptr1
                                .add(16 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>() = len14;
                            *ptr1
                                .add(15 * ::core::mem::size_of::<*const u8>())
                                .cast::<*mut u8>() = result14;
                        }
                        None => {
                            *ptr1
                                .add(14 * ::core::mem::size_of::<*const u8>())
                                .cast::<u8>() = (0i32) as u8;
                        }
                    };
                    match token_endpoint_auth_methods_supported2 {
                        Some(e) => {
                            *ptr1
                                .add(17 * ::core::mem::size_of::<*const u8>())
                                .cast::<u8>() = (1i32) as u8;
                            let vec16 = e;
                            let len16 = vec16.len();
                            let layout16 = _rt::alloc::Layout::from_size_align_unchecked(
                                vec16.len() * (2 * ::core::mem::size_of::<*const u8>()),
                                ::core::mem::size_of::<*const u8>(),
                            );
                            let result16 = if layout16.size() != 0 {
                                let ptr = _rt::alloc::alloc(layout16).cast::<u8>();
                                if ptr.is_null() {
                                    _rt::alloc::handle_alloc_error(layout16);
                                }
                                ptr
                            } else {
                                ::core::ptr::null_mut()
                            };
                            for (i, e) in vec16.into_iter().enumerate() {
                                let base = result16
                                    .add(i * (2 * ::core::mem::size_of::<*const u8>()));
                                {
                                    let vec15 = (e.into_bytes()).into_boxed_slice();
                                    let ptr15 = vec15.as_ptr().cast::<u8>();
                                    let len15 = vec15.len();
                                    ::core::mem::forget(vec15);
                                    *base
                                        .add(::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len15;
                                    *base.add(0).cast::<*mut u8>() = ptr15.cast_mut();
                                }
                            }
                            *ptr1
                                .add(19 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>() = len16;
                            *ptr1
                                .add(18 * ::core::mem::size_of::<*const u8>())
                                .cast::<*mut u8>() = result16;
                        }
                        None => {
                            *ptr1
                                .add(17 * ::core::mem::size_of::<*const u8>())
                                .cast::<u8>() = (0i32) as u8;
                        }
                    };
                    match service_documentation2 {
                        Some(e) => {
                            *ptr1
                                .add(20 * ::core::mem::size_of::<*const u8>())
                                .cast::<u8>() = (1i32) as u8;
                            let vec17 = (e.into_bytes()).into_boxed_slice();
                            let ptr17 = vec17.as_ptr().cast::<u8>();
                            let len17 = vec17.len();
                            ::core::mem::forget(vec17);
                            *ptr1
                                .add(22 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>() = len17;
                            *ptr1
                                .add(21 * ::core::mem::size_of::<*const u8>())
                                .cast::<*mut u8>() = ptr17.cast_mut();
                        }
                        None => {
                            *ptr1
                                .add(20 * ::core::mem::size_of::<*const u8>())
                                .cast::<u8>() = (0i32) as u8;
                        }
                    };
                    match registration_endpoint2 {
                        Some(e) => {
                            *ptr1
                                .add(23 * ::core::mem::size_of::<*const u8>())
                                .cast::<u8>() = (1i32) as u8;
                            let vec18 = (e.into_bytes()).into_boxed_slice();
                            let ptr18 = vec18.as_ptr().cast::<u8>();
                            let len18 = vec18.len();
                            ::core::mem::forget(vec18);
                            *ptr1
                                .add(25 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>() = len18;
                            *ptr1
                                .add(24 * ::core::mem::size_of::<*const u8>())
                                .cast::<*mut u8>() = ptr18.cast_mut();
                        }
                        None => {
                            *ptr1
                                .add(23 * ::core::mem::size_of::<*const u8>())
                                .cast::<u8>() = (0i32) as u8;
                        }
                    };
                    ptr1
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn __post_return_get_server_metadata<T: Guest>(
                    arg0: *mut u8,
                ) {
                    let l0 = *arg0.add(0).cast::<*mut u8>();
                    let l1 = *arg0
                        .add(::core::mem::size_of::<*const u8>())
                        .cast::<usize>();
                    _rt::cabi_dealloc(l0, l1, 1);
                    let l2 = *arg0
                        .add(2 * ::core::mem::size_of::<*const u8>())
                        .cast::<*mut u8>();
                    let l3 = *arg0
                        .add(3 * ::core::mem::size_of::<*const u8>())
                        .cast::<usize>();
                    _rt::cabi_dealloc(l2, l3, 1);
                    let l4 = *arg0
                        .add(4 * ::core::mem::size_of::<*const u8>())
                        .cast::<*mut u8>();
                    let l5 = *arg0
                        .add(5 * ::core::mem::size_of::<*const u8>())
                        .cast::<usize>();
                    _rt::cabi_dealloc(l4, l5, 1);
                    let l6 = *arg0
                        .add(6 * ::core::mem::size_of::<*const u8>())
                        .cast::<*mut u8>();
                    let l7 = *arg0
                        .add(7 * ::core::mem::size_of::<*const u8>())
                        .cast::<usize>();
                    _rt::cabi_dealloc(l6, l7, 1);
                    let l8 = *arg0
                        .add(8 * ::core::mem::size_of::<*const u8>())
                        .cast::<*mut u8>();
                    let l9 = *arg0
                        .add(9 * ::core::mem::size_of::<*const u8>())
                        .cast::<usize>();
                    let base12 = l8;
                    let len12 = l9;
                    for i in 0..len12 {
                        let base = base12
                            .add(i * (2 * ::core::mem::size_of::<*const u8>()));
                        {
                            let l10 = *base.add(0).cast::<*mut u8>();
                            let l11 = *base
                                .add(::core::mem::size_of::<*const u8>())
                                .cast::<usize>();
                            _rt::cabi_dealloc(l10, l11, 1);
                        }
                    }
                    _rt::cabi_dealloc(
                        base12,
                        len12 * (2 * ::core::mem::size_of::<*const u8>()),
                        ::core::mem::size_of::<*const u8>(),
                    );
                    let l13 = *arg0
                        .add(10 * ::core::mem::size_of::<*const u8>())
                        .cast::<*mut u8>();
                    let l14 = *arg0
                        .add(11 * ::core::mem::size_of::<*const u8>())
                        .cast::<usize>();
                    let base17 = l13;
                    let len17 = l14;
                    for i in 0..len17 {
                        let base = base17
                            .add(i * (2 * ::core::mem::size_of::<*const u8>()));
                        {
                            let l15 = *base.add(0).cast::<*mut u8>();
                            let l16 = *base
                                .add(::core::mem::size_of::<*const u8>())
                                .cast::<usize>();
                            _rt::cabi_dealloc(l15, l16, 1);
                        }
                    }
                    _rt::cabi_dealloc(
                        base17,
                        len17 * (2 * ::core::mem::size_of::<*const u8>()),
                        ::core::mem::size_of::<*const u8>(),
                    );
                    let l18 = *arg0
                        .add(12 * ::core::mem::size_of::<*const u8>())
                        .cast::<*mut u8>();
                    let l19 = *arg0
                        .add(13 * ::core::mem::size_of::<*const u8>())
                        .cast::<usize>();
                    let base22 = l18;
                    let len22 = l19;
                    for i in 0..len22 {
                        let base = base22
                            .add(i * (2 * ::core::mem::size_of::<*const u8>()));
                        {
                            let l20 = *base.add(0).cast::<*mut u8>();
                            let l21 = *base
                                .add(::core::mem::size_of::<*const u8>())
                                .cast::<usize>();
                            _rt::cabi_dealloc(l20, l21, 1);
                        }
                    }
                    _rt::cabi_dealloc(
                        base22,
                        len22 * (2 * ::core::mem::size_of::<*const u8>()),
                        ::core::mem::size_of::<*const u8>(),
                    );
                    let l23 = i32::from(
                        *arg0.add(14 * ::core::mem::size_of::<*const u8>()).cast::<u8>(),
                    );
                    match l23 {
                        0 => {}
                        _ => {
                            let l24 = *arg0
                                .add(15 * ::core::mem::size_of::<*const u8>())
                                .cast::<*mut u8>();
                            let l25 = *arg0
                                .add(16 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>();
                            let base28 = l24;
                            let len28 = l25;
                            for i in 0..len28 {
                                let base = base28
                                    .add(i * (2 * ::core::mem::size_of::<*const u8>()));
                                {
                                    let l26 = *base.add(0).cast::<*mut u8>();
                                    let l27 = *base
                                        .add(::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l26, l27, 1);
                                }
                            }
                            _rt::cabi_dealloc(
                                base28,
                                len28 * (2 * ::core::mem::size_of::<*const u8>()),
                                ::core::mem::size_of::<*const u8>(),
                            );
                        }
                    }
                    let l29 = i32::from(
                        *arg0.add(17 * ::core::mem::size_of::<*const u8>()).cast::<u8>(),
                    );
                    match l29 {
                        0 => {}
                        _ => {
                            let l30 = *arg0
                                .add(18 * ::core::mem::size_of::<*const u8>())
                                .cast::<*mut u8>();
                            let l31 = *arg0
                                .add(19 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>();
                            let base34 = l30;
                            let len34 = l31;
                            for i in 0..len34 {
                                let base = base34
                                    .add(i * (2 * ::core::mem::size_of::<*const u8>()));
                                {
                                    let l32 = *base.add(0).cast::<*mut u8>();
                                    let l33 = *base
                                        .add(::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l32, l33, 1);
                                }
                            }
                            _rt::cabi_dealloc(
                                base34,
                                len34 * (2 * ::core::mem::size_of::<*const u8>()),
                                ::core::mem::size_of::<*const u8>(),
                            );
                        }
                    }
                    let l35 = i32::from(
                        *arg0.add(20 * ::core::mem::size_of::<*const u8>()).cast::<u8>(),
                    );
                    match l35 {
                        0 => {}
                        _ => {
                            let l36 = *arg0
                                .add(21 * ::core::mem::size_of::<*const u8>())
                                .cast::<*mut u8>();
                            let l37 = *arg0
                                .add(22 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>();
                            _rt::cabi_dealloc(l36, l37, 1);
                        }
                    }
                    let l38 = i32::from(
                        *arg0.add(23 * ::core::mem::size_of::<*const u8>()).cast::<u8>(),
                    );
                    match l38 {
                        0 => {}
                        _ => {
                            let l39 = *arg0
                                .add(24 * ::core::mem::size_of::<*const u8>())
                                .cast::<*mut u8>();
                            let l40 = *arg0
                                .add(25 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>();
                            _rt::cabi_dealloc(l39, l40, 1);
                        }
                    }
                }
                pub trait Guest {
                    /// Get OAuth 2.0 Protected Resource Metadata
                    fn get_resource_metadata() -> ResourceMetadata;
                    /// Get OAuth 2.0 Authorization Server Metadata
                    fn get_server_metadata() -> ServerMetadata;
                }
                #[doc(hidden)]
                macro_rules! __export_fastertools_mcp_oauth_discovery_0_1_16_cabi {
                    ($ty:ident with_types_in $($path_to_types:tt)*) => {
                        const _ : () = { #[unsafe (export_name =
                        "fastertools:mcp/oauth-discovery@0.1.16#get-resource-metadata")]
                        unsafe extern "C" fn export_get_resource_metadata() -> * mut u8 {
                        unsafe { $($path_to_types)*::
                        _export_get_resource_metadata_cabi::<$ty > () } } #[unsafe
                        (export_name =
                        "cabi_post_fastertools:mcp/oauth-discovery@0.1.16#get-resource-metadata")]
                        unsafe extern "C" fn _post_return_get_resource_metadata(arg0 : *
                        mut u8,) { unsafe { $($path_to_types)*::
                        __post_return_get_resource_metadata::<$ty > (arg0) } } #[unsafe
                        (export_name =
                        "fastertools:mcp/oauth-discovery@0.1.16#get-server-metadata")]
                        unsafe extern "C" fn export_get_server_metadata() -> * mut u8 {
                        unsafe { $($path_to_types)*::
                        _export_get_server_metadata_cabi::<$ty > () } } #[unsafe
                        (export_name =
                        "cabi_post_fastertools:mcp/oauth-discovery@0.1.16#get-server-metadata")]
                        unsafe extern "C" fn _post_return_get_server_metadata(arg0 : *
                        mut u8,) { unsafe { $($path_to_types)*::
                        __post_return_get_server_metadata::<$ty > (arg0) } } };
                    };
                }
                #[doc(hidden)]
                pub(crate) use __export_fastertools_mcp_oauth_discovery_0_1_16_cabi;
                #[cfg_attr(target_pointer_width = "64", repr(align(8)))]
                #[cfg_attr(target_pointer_width = "32", repr(align(4)))]
                struct _RetArea(
                    [::core::mem::MaybeUninit<
                        u8,
                    >; 26 * ::core::mem::size_of::<*const u8>()],
                );
                static mut _RET_AREA: _RetArea = _RetArea(
                    [::core::mem::MaybeUninit::uninit(); 26
                        * ::core::mem::size_of::<*const u8>()],
                );
            }
            /// MCP-specific authorization helpers
            #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
            pub mod mcp_authorization {
                #[used]
                #[doc(hidden)]
                static __FORCE_SECTION_REF: fn() = super::super::super::super::__link_custom_section_describing_imports;
                use super::super::super::super::_rt;
                pub type AuthContext = super::super::super::super::exports::fastertools::mcp::authorization::AuthContext;
                pub type AuthError = super::super::super::super::exports::fastertools::mcp::authorization::AuthError;
                pub type JsonValue = super::super::super::super::fastertools::mcp::types::JsonValue;
                /// MCP method authorization request
                #[derive(Clone, serde::Deserialize, serde::Serialize)]
                pub struct McpAuthRequest {
                    /// Authorization context from token validation
                    pub context: AuthContext,
                    /// MCP method being called (e.g., "tools/call", "resources/list")
                    pub method: _rt::String,
                    /// Parameters from the JSON-RPC request
                    pub params: Option<JsonValue>,
                }
                impl ::core::fmt::Debug for McpAuthRequest {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter<'_>,
                    ) -> ::core::fmt::Result {
                        f.debug_struct("McpAuthRequest")
                            .field("context", &self.context)
                            .field("method", &self.method)
                            .field("params", &self.params)
                            .finish()
                    }
                }
                /// MCP tool call authorization
                #[derive(Clone, serde::Deserialize, serde::Serialize)]
                pub struct ToolAuthRequest {
                    /// Authorization context
                    pub context: AuthContext,
                    /// Tool name being called
                    pub tool_name: _rt::String,
                    /// Tool arguments
                    pub arguments: Option<JsonValue>,
                }
                impl ::core::fmt::Debug for ToolAuthRequest {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter<'_>,
                    ) -> ::core::fmt::Result {
                        f.debug_struct("ToolAuthRequest")
                            .field("context", &self.context)
                            .field("tool-name", &self.tool_name)
                            .field("arguments", &self.arguments)
                            .finish()
                    }
                }
                /// Resource operation types
                #[repr(u8)]
                #[derive(
                    Clone,
                    Copy,
                    Eq,
                    Ord,
                    PartialEq,
                    PartialOrd,
                    serde::Deserialize,
                    serde::Serialize
                )]
                pub enum ResourceOperation {
                    ListOp,
                    ReadOp,
                    SubscribeOp,
                    UnsubscribeOp,
                }
                impl ::core::fmt::Debug for ResourceOperation {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter<'_>,
                    ) -> ::core::fmt::Result {
                        match self {
                            ResourceOperation::ListOp => {
                                f.debug_tuple("ResourceOperation::ListOp").finish()
                            }
                            ResourceOperation::ReadOp => {
                                f.debug_tuple("ResourceOperation::ReadOp").finish()
                            }
                            ResourceOperation::SubscribeOp => {
                                f.debug_tuple("ResourceOperation::SubscribeOp").finish()
                            }
                            ResourceOperation::UnsubscribeOp => {
                                f.debug_tuple("ResourceOperation::UnsubscribeOp").finish()
                            }
                        }
                    }
                }
                impl ResourceOperation {
                    #[doc(hidden)]
                    pub unsafe fn _lift(val: u8) -> ResourceOperation {
                        if !cfg!(debug_assertions) {
                            return ::core::mem::transmute(val);
                        }
                        match val {
                            0 => ResourceOperation::ListOp,
                            1 => ResourceOperation::ReadOp,
                            2 => ResourceOperation::SubscribeOp,
                            3 => ResourceOperation::UnsubscribeOp,
                            _ => panic!("invalid enum discriminant"),
                        }
                    }
                }
                /// MCP resource authorization
                #[derive(Clone, serde::Deserialize, serde::Serialize)]
                pub struct ResourceAuthRequest {
                    /// Authorization context
                    pub context: AuthContext,
                    /// Resource URI being accessed
                    pub uri: _rt::String,
                    /// Operation type (read, list, subscribe)
                    pub operation: ResourceOperation,
                }
                impl ::core::fmt::Debug for ResourceAuthRequest {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter<'_>,
                    ) -> ::core::fmt::Result {
                        f.debug_struct("ResourceAuthRequest")
                            .field("context", &self.context)
                            .field("uri", &self.uri)
                            .field("operation", &self.operation)
                            .finish()
                    }
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_authorize_method_cabi<T: Guest>(
                    arg0: *mut u8,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let l0 = i32::from(*arg0.add(0).cast::<u8>());
                    let l4 = i32::from(
                        *arg0.add(3 * ::core::mem::size_of::<*const u8>()).cast::<u8>(),
                    );
                    let l8 = *arg0
                        .add(6 * ::core::mem::size_of::<*const u8>())
                        .cast::<*mut u8>();
                    let l9 = *arg0
                        .add(7 * ::core::mem::size_of::<*const u8>())
                        .cast::<usize>();
                    let base13 = l8;
                    let len13 = l9;
                    let mut result13 = _rt::Vec::with_capacity(len13);
                    for i in 0..len13 {
                        let base = base13
                            .add(i * (2 * ::core::mem::size_of::<*const u8>()));
                        let e13 = {
                            let l10 = *base.add(0).cast::<*mut u8>();
                            let l11 = *base
                                .add(::core::mem::size_of::<*const u8>())
                                .cast::<usize>();
                            let len12 = l11;
                            let bytes12 = _rt::Vec::from_raw_parts(
                                l10.cast(),
                                len12,
                                len12,
                            );
                            _rt::string_lift(bytes12)
                        };
                        result13.push(e13);
                    }
                    _rt::cabi_dealloc(
                        base13,
                        len13 * (2 * ::core::mem::size_of::<*const u8>()),
                        ::core::mem::size_of::<*const u8>(),
                    );
                    let l14 = i32::from(
                        *arg0.add(8 * ::core::mem::size_of::<*const u8>()).cast::<u8>(),
                    );
                    let l18 = i32::from(
                        *arg0.add(11 * ::core::mem::size_of::<*const u8>()).cast::<u8>(),
                    );
                    let l22 = *arg0
                        .add(14 * ::core::mem::size_of::<*const u8>())
                        .cast::<*mut u8>();
                    let l23 = *arg0
                        .add(15 * ::core::mem::size_of::<*const u8>())
                        .cast::<usize>();
                    let base30 = l22;
                    let len30 = l23;
                    let mut result30 = _rt::Vec::with_capacity(len30);
                    for i in 0..len30 {
                        let base = base30
                            .add(i * (4 * ::core::mem::size_of::<*const u8>()));
                        let e30 = {
                            let l24 = *base.add(0).cast::<*mut u8>();
                            let l25 = *base
                                .add(::core::mem::size_of::<*const u8>())
                                .cast::<usize>();
                            let len26 = l25;
                            let bytes26 = _rt::Vec::from_raw_parts(
                                l24.cast(),
                                len26,
                                len26,
                            );
                            let l27 = *base
                                .add(2 * ::core::mem::size_of::<*const u8>())
                                .cast::<*mut u8>();
                            let l28 = *base
                                .add(3 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>();
                            let len29 = l28;
                            let bytes29 = _rt::Vec::from_raw_parts(
                                l27.cast(),
                                len29,
                                len29,
                            );
                            (_rt::string_lift(bytes26), _rt::string_lift(bytes29))
                        };
                        result30.push(e30);
                    }
                    _rt::cabi_dealloc(
                        base30,
                        len30 * (4 * ::core::mem::size_of::<*const u8>()),
                        ::core::mem::size_of::<*const u8>(),
                    );
                    let l31 = i32::from(
                        *arg0.add(16 * ::core::mem::size_of::<*const u8>()).cast::<u8>(),
                    );
                    let l33 = i32::from(
                        *arg0
                            .add(16 + 16 * ::core::mem::size_of::<*const u8>())
                            .cast::<u8>(),
                    );
                    let l35 = *arg0
                        .add(32 + 16 * ::core::mem::size_of::<*const u8>())
                        .cast::<*mut u8>();
                    let l36 = *arg0
                        .add(32 + 17 * ::core::mem::size_of::<*const u8>())
                        .cast::<usize>();
                    let len37 = l36;
                    let bytes37 = _rt::Vec::from_raw_parts(l35.cast(), len37, len37);
                    let l38 = i32::from(
                        *arg0
                            .add(32 + 18 * ::core::mem::size_of::<*const u8>())
                            .cast::<u8>(),
                    );
                    let result42 = T::authorize_method(McpAuthRequest {
                        context: super::super::super::super::exports::fastertools::mcp::authorization::AuthContext {
                            client_id: match l0 {
                                0 => None,
                                1 => {
                                    let e = {
                                        let l1 = *arg0
                                            .add(::core::mem::size_of::<*const u8>())
                                            .cast::<*mut u8>();
                                        let l2 = *arg0
                                            .add(2 * ::core::mem::size_of::<*const u8>())
                                            .cast::<usize>();
                                        let len3 = l2;
                                        let bytes3 = _rt::Vec::from_raw_parts(
                                            l1.cast(),
                                            len3,
                                            len3,
                                        );
                                        _rt::string_lift(bytes3)
                                    };
                                    Some(e)
                                }
                                _ => _rt::invalid_enum_discriminant(),
                            },
                            user_id: match l4 {
                                0 => None,
                                1 => {
                                    let e = {
                                        let l5 = *arg0
                                            .add(4 * ::core::mem::size_of::<*const u8>())
                                            .cast::<*mut u8>();
                                        let l6 = *arg0
                                            .add(5 * ::core::mem::size_of::<*const u8>())
                                            .cast::<usize>();
                                        let len7 = l6;
                                        let bytes7 = _rt::Vec::from_raw_parts(
                                            l5.cast(),
                                            len7,
                                            len7,
                                        );
                                        _rt::string_lift(bytes7)
                                    };
                                    Some(e)
                                }
                                _ => _rt::invalid_enum_discriminant(),
                            },
                            scopes: result13,
                            issuer: match l14 {
                                0 => None,
                                1 => {
                                    let e = {
                                        let l15 = *arg0
                                            .add(9 * ::core::mem::size_of::<*const u8>())
                                            .cast::<*mut u8>();
                                        let l16 = *arg0
                                            .add(10 * ::core::mem::size_of::<*const u8>())
                                            .cast::<usize>();
                                        let len17 = l16;
                                        let bytes17 = _rt::Vec::from_raw_parts(
                                            l15.cast(),
                                            len17,
                                            len17,
                                        );
                                        _rt::string_lift(bytes17)
                                    };
                                    Some(e)
                                }
                                _ => _rt::invalid_enum_discriminant(),
                            },
                            audience: match l18 {
                                0 => None,
                                1 => {
                                    let e = {
                                        let l19 = *arg0
                                            .add(12 * ::core::mem::size_of::<*const u8>())
                                            .cast::<*mut u8>();
                                        let l20 = *arg0
                                            .add(13 * ::core::mem::size_of::<*const u8>())
                                            .cast::<usize>();
                                        let len21 = l20;
                                        let bytes21 = _rt::Vec::from_raw_parts(
                                            l19.cast(),
                                            len21,
                                            len21,
                                        );
                                        _rt::string_lift(bytes21)
                                    };
                                    Some(e)
                                }
                                _ => _rt::invalid_enum_discriminant(),
                            },
                            claims: result30,
                            exp: match l31 {
                                0 => None,
                                1 => {
                                    let e = {
                                        let l32 = *arg0
                                            .add(8 + 16 * ::core::mem::size_of::<*const u8>())
                                            .cast::<i64>();
                                        l32 as u64
                                    };
                                    Some(e)
                                }
                                _ => _rt::invalid_enum_discriminant(),
                            },
                            iat: match l33 {
                                0 => None,
                                1 => {
                                    let e = {
                                        let l34 = *arg0
                                            .add(24 + 16 * ::core::mem::size_of::<*const u8>())
                                            .cast::<i64>();
                                        l34 as u64
                                    };
                                    Some(e)
                                }
                                _ => _rt::invalid_enum_discriminant(),
                            },
                        },
                        method: _rt::string_lift(bytes37),
                        params: match l38 {
                            0 => None,
                            1 => {
                                let e = {
                                    let l39 = *arg0
                                        .add(32 + 19 * ::core::mem::size_of::<*const u8>())
                                        .cast::<*mut u8>();
                                    let l40 = *arg0
                                        .add(32 + 20 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    let len41 = l40;
                                    let bytes41 = _rt::Vec::from_raw_parts(
                                        l39.cast(),
                                        len41,
                                        len41,
                                    );
                                    _rt::string_lift(bytes41)
                                };
                                Some(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                        },
                    });
                    _rt::cabi_dealloc(
                        arg0,
                        40 + 20 * ::core::mem::size_of::<*const u8>(),
                        8,
                    );
                    let ptr43 = (&raw mut _RET_AREA.0).cast::<u8>();
                    match result42 {
                        Ok(_) => {
                            *ptr43.add(0).cast::<u8>() = (0i32) as u8;
                        }
                        Err(e) => {
                            *ptr43.add(0).cast::<u8>() = (1i32) as u8;
                            let super::super::super::super::exports::fastertools::mcp::authorization::AuthError {
                                status: status44,
                                error_code: error_code44,
                                description: description44,
                                www_authenticate: www_authenticate44,
                            } = e;
                            *ptr43
                                .add(::core::mem::size_of::<*const u8>())
                                .cast::<u16>() = (_rt::as_i32(status44)) as u16;
                            let vec45 = (error_code44.into_bytes()).into_boxed_slice();
                            let ptr45 = vec45.as_ptr().cast::<u8>();
                            let len45 = vec45.len();
                            ::core::mem::forget(vec45);
                            *ptr43
                                .add(3 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>() = len45;
                            *ptr43
                                .add(2 * ::core::mem::size_of::<*const u8>())
                                .cast::<*mut u8>() = ptr45.cast_mut();
                            let vec46 = (description44.into_bytes()).into_boxed_slice();
                            let ptr46 = vec46.as_ptr().cast::<u8>();
                            let len46 = vec46.len();
                            ::core::mem::forget(vec46);
                            *ptr43
                                .add(5 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>() = len46;
                            *ptr43
                                .add(4 * ::core::mem::size_of::<*const u8>())
                                .cast::<*mut u8>() = ptr46.cast_mut();
                            match www_authenticate44 {
                                Some(e) => {
                                    *ptr43
                                        .add(6 * ::core::mem::size_of::<*const u8>())
                                        .cast::<u8>() = (1i32) as u8;
                                    let vec47 = (e.into_bytes()).into_boxed_slice();
                                    let ptr47 = vec47.as_ptr().cast::<u8>();
                                    let len47 = vec47.len();
                                    ::core::mem::forget(vec47);
                                    *ptr43
                                        .add(8 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len47;
                                    *ptr43
                                        .add(7 * ::core::mem::size_of::<*const u8>())
                                        .cast::<*mut u8>() = ptr47.cast_mut();
                                }
                                None => {
                                    *ptr43
                                        .add(6 * ::core::mem::size_of::<*const u8>())
                                        .cast::<u8>() = (0i32) as u8;
                                }
                            };
                        }
                    };
                    ptr43
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn __post_return_authorize_method<T: Guest>(arg0: *mut u8) {
                    let l0 = i32::from(*arg0.add(0).cast::<u8>());
                    match l0 {
                        0 => {}
                        _ => {
                            let l1 = *arg0
                                .add(2 * ::core::mem::size_of::<*const u8>())
                                .cast::<*mut u8>();
                            let l2 = *arg0
                                .add(3 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>();
                            _rt::cabi_dealloc(l1, l2, 1);
                            let l3 = *arg0
                                .add(4 * ::core::mem::size_of::<*const u8>())
                                .cast::<*mut u8>();
                            let l4 = *arg0
                                .add(5 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>();
                            _rt::cabi_dealloc(l3, l4, 1);
                            let l5 = i32::from(
                                *arg0
                                    .add(6 * ::core::mem::size_of::<*const u8>())
                                    .cast::<u8>(),
                            );
                            match l5 {
                                0 => {}
                                _ => {
                                    let l6 = *arg0
                                        .add(7 * ::core::mem::size_of::<*const u8>())
                                        .cast::<*mut u8>();
                                    let l7 = *arg0
                                        .add(8 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l6, l7, 1);
                                }
                            }
                        }
                    }
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_authorize_tool_cabi<T: Guest>(
                    arg0: *mut u8,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let l0 = i32::from(*arg0.add(0).cast::<u8>());
                    let l4 = i32::from(
                        *arg0.add(3 * ::core::mem::size_of::<*const u8>()).cast::<u8>(),
                    );
                    let l8 = *arg0
                        .add(6 * ::core::mem::size_of::<*const u8>())
                        .cast::<*mut u8>();
                    let l9 = *arg0
                        .add(7 * ::core::mem::size_of::<*const u8>())
                        .cast::<usize>();
                    let base13 = l8;
                    let len13 = l9;
                    let mut result13 = _rt::Vec::with_capacity(len13);
                    for i in 0..len13 {
                        let base = base13
                            .add(i * (2 * ::core::mem::size_of::<*const u8>()));
                        let e13 = {
                            let l10 = *base.add(0).cast::<*mut u8>();
                            let l11 = *base
                                .add(::core::mem::size_of::<*const u8>())
                                .cast::<usize>();
                            let len12 = l11;
                            let bytes12 = _rt::Vec::from_raw_parts(
                                l10.cast(),
                                len12,
                                len12,
                            );
                            _rt::string_lift(bytes12)
                        };
                        result13.push(e13);
                    }
                    _rt::cabi_dealloc(
                        base13,
                        len13 * (2 * ::core::mem::size_of::<*const u8>()),
                        ::core::mem::size_of::<*const u8>(),
                    );
                    let l14 = i32::from(
                        *arg0.add(8 * ::core::mem::size_of::<*const u8>()).cast::<u8>(),
                    );
                    let l18 = i32::from(
                        *arg0.add(11 * ::core::mem::size_of::<*const u8>()).cast::<u8>(),
                    );
                    let l22 = *arg0
                        .add(14 * ::core::mem::size_of::<*const u8>())
                        .cast::<*mut u8>();
                    let l23 = *arg0
                        .add(15 * ::core::mem::size_of::<*const u8>())
                        .cast::<usize>();
                    let base30 = l22;
                    let len30 = l23;
                    let mut result30 = _rt::Vec::with_capacity(len30);
                    for i in 0..len30 {
                        let base = base30
                            .add(i * (4 * ::core::mem::size_of::<*const u8>()));
                        let e30 = {
                            let l24 = *base.add(0).cast::<*mut u8>();
                            let l25 = *base
                                .add(::core::mem::size_of::<*const u8>())
                                .cast::<usize>();
                            let len26 = l25;
                            let bytes26 = _rt::Vec::from_raw_parts(
                                l24.cast(),
                                len26,
                                len26,
                            );
                            let l27 = *base
                                .add(2 * ::core::mem::size_of::<*const u8>())
                                .cast::<*mut u8>();
                            let l28 = *base
                                .add(3 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>();
                            let len29 = l28;
                            let bytes29 = _rt::Vec::from_raw_parts(
                                l27.cast(),
                                len29,
                                len29,
                            );
                            (_rt::string_lift(bytes26), _rt::string_lift(bytes29))
                        };
                        result30.push(e30);
                    }
                    _rt::cabi_dealloc(
                        base30,
                        len30 * (4 * ::core::mem::size_of::<*const u8>()),
                        ::core::mem::size_of::<*const u8>(),
                    );
                    let l31 = i32::from(
                        *arg0.add(16 * ::core::mem::size_of::<*const u8>()).cast::<u8>(),
                    );
                    let l33 = i32::from(
                        *arg0
                            .add(16 + 16 * ::core::mem::size_of::<*const u8>())
                            .cast::<u8>(),
                    );
                    let l35 = *arg0
                        .add(32 + 16 * ::core::mem::size_of::<*const u8>())
                        .cast::<*mut u8>();
                    let l36 = *arg0
                        .add(32 + 17 * ::core::mem::size_of::<*const u8>())
                        .cast::<usize>();
                    let len37 = l36;
                    let bytes37 = _rt::Vec::from_raw_parts(l35.cast(), len37, len37);
                    let l38 = i32::from(
                        *arg0
                            .add(32 + 18 * ::core::mem::size_of::<*const u8>())
                            .cast::<u8>(),
                    );
                    let result42 = T::authorize_tool(ToolAuthRequest {
                        context: super::super::super::super::exports::fastertools::mcp::authorization::AuthContext {
                            client_id: match l0 {
                                0 => None,
                                1 => {
                                    let e = {
                                        let l1 = *arg0
                                            .add(::core::mem::size_of::<*const u8>())
                                            .cast::<*mut u8>();
                                        let l2 = *arg0
                                            .add(2 * ::core::mem::size_of::<*const u8>())
                                            .cast::<usize>();
                                        let len3 = l2;
                                        let bytes3 = _rt::Vec::from_raw_parts(
                                            l1.cast(),
                                            len3,
                                            len3,
                                        );
                                        _rt::string_lift(bytes3)
                                    };
                                    Some(e)
                                }
                                _ => _rt::invalid_enum_discriminant(),
                            },
                            user_id: match l4 {
                                0 => None,
                                1 => {
                                    let e = {
                                        let l5 = *arg0
                                            .add(4 * ::core::mem::size_of::<*const u8>())
                                            .cast::<*mut u8>();
                                        let l6 = *arg0
                                            .add(5 * ::core::mem::size_of::<*const u8>())
                                            .cast::<usize>();
                                        let len7 = l6;
                                        let bytes7 = _rt::Vec::from_raw_parts(
                                            l5.cast(),
                                            len7,
                                            len7,
                                        );
                                        _rt::string_lift(bytes7)
                                    };
                                    Some(e)
                                }
                                _ => _rt::invalid_enum_discriminant(),
                            },
                            scopes: result13,
                            issuer: match l14 {
                                0 => None,
                                1 => {
                                    let e = {
                                        let l15 = *arg0
                                            .add(9 * ::core::mem::size_of::<*const u8>())
                                            .cast::<*mut u8>();
                                        let l16 = *arg0
                                            .add(10 * ::core::mem::size_of::<*const u8>())
                                            .cast::<usize>();
                                        let len17 = l16;
                                        let bytes17 = _rt::Vec::from_raw_parts(
                                            l15.cast(),
                                            len17,
                                            len17,
                                        );
                                        _rt::string_lift(bytes17)
                                    };
                                    Some(e)
                                }
                                _ => _rt::invalid_enum_discriminant(),
                            },
                            audience: match l18 {
                                0 => None,
                                1 => {
                                    let e = {
                                        let l19 = *arg0
                                            .add(12 * ::core::mem::size_of::<*const u8>())
                                            .cast::<*mut u8>();
                                        let l20 = *arg0
                                            .add(13 * ::core::mem::size_of::<*const u8>())
                                            .cast::<usize>();
                                        let len21 = l20;
                                        let bytes21 = _rt::Vec::from_raw_parts(
                                            l19.cast(),
                                            len21,
                                            len21,
                                        );
                                        _rt::string_lift(bytes21)
                                    };
                                    Some(e)
                                }
                                _ => _rt::invalid_enum_discriminant(),
                            },
                            claims: result30,
                            exp: match l31 {
                                0 => None,
                                1 => {
                                    let e = {
                                        let l32 = *arg0
                                            .add(8 + 16 * ::core::mem::size_of::<*const u8>())
                                            .cast::<i64>();
                                        l32 as u64
                                    };
                                    Some(e)
                                }
                                _ => _rt::invalid_enum_discriminant(),
                            },
                            iat: match l33 {
                                0 => None,
                                1 => {
                                    let e = {
                                        let l34 = *arg0
                                            .add(24 + 16 * ::core::mem::size_of::<*const u8>())
                                            .cast::<i64>();
                                        l34 as u64
                                    };
                                    Some(e)
                                }
                                _ => _rt::invalid_enum_discriminant(),
                            },
                        },
                        tool_name: _rt::string_lift(bytes37),
                        arguments: match l38 {
                            0 => None,
                            1 => {
                                let e = {
                                    let l39 = *arg0
                                        .add(32 + 19 * ::core::mem::size_of::<*const u8>())
                                        .cast::<*mut u8>();
                                    let l40 = *arg0
                                        .add(32 + 20 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    let len41 = l40;
                                    let bytes41 = _rt::Vec::from_raw_parts(
                                        l39.cast(),
                                        len41,
                                        len41,
                                    );
                                    _rt::string_lift(bytes41)
                                };
                                Some(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                        },
                    });
                    _rt::cabi_dealloc(
                        arg0,
                        40 + 20 * ::core::mem::size_of::<*const u8>(),
                        8,
                    );
                    let ptr43 = (&raw mut _RET_AREA.0).cast::<u8>();
                    match result42 {
                        Ok(_) => {
                            *ptr43.add(0).cast::<u8>() = (0i32) as u8;
                        }
                        Err(e) => {
                            *ptr43.add(0).cast::<u8>() = (1i32) as u8;
                            let super::super::super::super::exports::fastertools::mcp::authorization::AuthError {
                                status: status44,
                                error_code: error_code44,
                                description: description44,
                                www_authenticate: www_authenticate44,
                            } = e;
                            *ptr43
                                .add(::core::mem::size_of::<*const u8>())
                                .cast::<u16>() = (_rt::as_i32(status44)) as u16;
                            let vec45 = (error_code44.into_bytes()).into_boxed_slice();
                            let ptr45 = vec45.as_ptr().cast::<u8>();
                            let len45 = vec45.len();
                            ::core::mem::forget(vec45);
                            *ptr43
                                .add(3 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>() = len45;
                            *ptr43
                                .add(2 * ::core::mem::size_of::<*const u8>())
                                .cast::<*mut u8>() = ptr45.cast_mut();
                            let vec46 = (description44.into_bytes()).into_boxed_slice();
                            let ptr46 = vec46.as_ptr().cast::<u8>();
                            let len46 = vec46.len();
                            ::core::mem::forget(vec46);
                            *ptr43
                                .add(5 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>() = len46;
                            *ptr43
                                .add(4 * ::core::mem::size_of::<*const u8>())
                                .cast::<*mut u8>() = ptr46.cast_mut();
                            match www_authenticate44 {
                                Some(e) => {
                                    *ptr43
                                        .add(6 * ::core::mem::size_of::<*const u8>())
                                        .cast::<u8>() = (1i32) as u8;
                                    let vec47 = (e.into_bytes()).into_boxed_slice();
                                    let ptr47 = vec47.as_ptr().cast::<u8>();
                                    let len47 = vec47.len();
                                    ::core::mem::forget(vec47);
                                    *ptr43
                                        .add(8 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len47;
                                    *ptr43
                                        .add(7 * ::core::mem::size_of::<*const u8>())
                                        .cast::<*mut u8>() = ptr47.cast_mut();
                                }
                                None => {
                                    *ptr43
                                        .add(6 * ::core::mem::size_of::<*const u8>())
                                        .cast::<u8>() = (0i32) as u8;
                                }
                            };
                        }
                    };
                    ptr43
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn __post_return_authorize_tool<T: Guest>(arg0: *mut u8) {
                    let l0 = i32::from(*arg0.add(0).cast::<u8>());
                    match l0 {
                        0 => {}
                        _ => {
                            let l1 = *arg0
                                .add(2 * ::core::mem::size_of::<*const u8>())
                                .cast::<*mut u8>();
                            let l2 = *arg0
                                .add(3 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>();
                            _rt::cabi_dealloc(l1, l2, 1);
                            let l3 = *arg0
                                .add(4 * ::core::mem::size_of::<*const u8>())
                                .cast::<*mut u8>();
                            let l4 = *arg0
                                .add(5 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>();
                            _rt::cabi_dealloc(l3, l4, 1);
                            let l5 = i32::from(
                                *arg0
                                    .add(6 * ::core::mem::size_of::<*const u8>())
                                    .cast::<u8>(),
                            );
                            match l5 {
                                0 => {}
                                _ => {
                                    let l6 = *arg0
                                        .add(7 * ::core::mem::size_of::<*const u8>())
                                        .cast::<*mut u8>();
                                    let l7 = *arg0
                                        .add(8 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l6, l7, 1);
                                }
                            }
                        }
                    }
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_authorize_resource_cabi<T: Guest>(
                    arg0: *mut u8,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let l0 = i32::from(*arg0.add(0).cast::<u8>());
                    let l4 = i32::from(
                        *arg0.add(3 * ::core::mem::size_of::<*const u8>()).cast::<u8>(),
                    );
                    let l8 = *arg0
                        .add(6 * ::core::mem::size_of::<*const u8>())
                        .cast::<*mut u8>();
                    let l9 = *arg0
                        .add(7 * ::core::mem::size_of::<*const u8>())
                        .cast::<usize>();
                    let base13 = l8;
                    let len13 = l9;
                    let mut result13 = _rt::Vec::with_capacity(len13);
                    for i in 0..len13 {
                        let base = base13
                            .add(i * (2 * ::core::mem::size_of::<*const u8>()));
                        let e13 = {
                            let l10 = *base.add(0).cast::<*mut u8>();
                            let l11 = *base
                                .add(::core::mem::size_of::<*const u8>())
                                .cast::<usize>();
                            let len12 = l11;
                            let bytes12 = _rt::Vec::from_raw_parts(
                                l10.cast(),
                                len12,
                                len12,
                            );
                            _rt::string_lift(bytes12)
                        };
                        result13.push(e13);
                    }
                    _rt::cabi_dealloc(
                        base13,
                        len13 * (2 * ::core::mem::size_of::<*const u8>()),
                        ::core::mem::size_of::<*const u8>(),
                    );
                    let l14 = i32::from(
                        *arg0.add(8 * ::core::mem::size_of::<*const u8>()).cast::<u8>(),
                    );
                    let l18 = i32::from(
                        *arg0.add(11 * ::core::mem::size_of::<*const u8>()).cast::<u8>(),
                    );
                    let l22 = *arg0
                        .add(14 * ::core::mem::size_of::<*const u8>())
                        .cast::<*mut u8>();
                    let l23 = *arg0
                        .add(15 * ::core::mem::size_of::<*const u8>())
                        .cast::<usize>();
                    let base30 = l22;
                    let len30 = l23;
                    let mut result30 = _rt::Vec::with_capacity(len30);
                    for i in 0..len30 {
                        let base = base30
                            .add(i * (4 * ::core::mem::size_of::<*const u8>()));
                        let e30 = {
                            let l24 = *base.add(0).cast::<*mut u8>();
                            let l25 = *base
                                .add(::core::mem::size_of::<*const u8>())
                                .cast::<usize>();
                            let len26 = l25;
                            let bytes26 = _rt::Vec::from_raw_parts(
                                l24.cast(),
                                len26,
                                len26,
                            );
                            let l27 = *base
                                .add(2 * ::core::mem::size_of::<*const u8>())
                                .cast::<*mut u8>();
                            let l28 = *base
                                .add(3 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>();
                            let len29 = l28;
                            let bytes29 = _rt::Vec::from_raw_parts(
                                l27.cast(),
                                len29,
                                len29,
                            );
                            (_rt::string_lift(bytes26), _rt::string_lift(bytes29))
                        };
                        result30.push(e30);
                    }
                    _rt::cabi_dealloc(
                        base30,
                        len30 * (4 * ::core::mem::size_of::<*const u8>()),
                        ::core::mem::size_of::<*const u8>(),
                    );
                    let l31 = i32::from(
                        *arg0.add(16 * ::core::mem::size_of::<*const u8>()).cast::<u8>(),
                    );
                    let l33 = i32::from(
                        *arg0
                            .add(16 + 16 * ::core::mem::size_of::<*const u8>())
                            .cast::<u8>(),
                    );
                    let l35 = *arg0
                        .add(32 + 16 * ::core::mem::size_of::<*const u8>())
                        .cast::<*mut u8>();
                    let l36 = *arg0
                        .add(32 + 17 * ::core::mem::size_of::<*const u8>())
                        .cast::<usize>();
                    let len37 = l36;
                    let bytes37 = _rt::Vec::from_raw_parts(l35.cast(), len37, len37);
                    let l38 = i32::from(
                        *arg0
                            .add(32 + 18 * ::core::mem::size_of::<*const u8>())
                            .cast::<u8>(),
                    );
                    let result39 = T::authorize_resource(ResourceAuthRequest {
                        context: super::super::super::super::exports::fastertools::mcp::authorization::AuthContext {
                            client_id: match l0 {
                                0 => None,
                                1 => {
                                    let e = {
                                        let l1 = *arg0
                                            .add(::core::mem::size_of::<*const u8>())
                                            .cast::<*mut u8>();
                                        let l2 = *arg0
                                            .add(2 * ::core::mem::size_of::<*const u8>())
                                            .cast::<usize>();
                                        let len3 = l2;
                                        let bytes3 = _rt::Vec::from_raw_parts(
                                            l1.cast(),
                                            len3,
                                            len3,
                                        );
                                        _rt::string_lift(bytes3)
                                    };
                                    Some(e)
                                }
                                _ => _rt::invalid_enum_discriminant(),
                            },
                            user_id: match l4 {
                                0 => None,
                                1 => {
                                    let e = {
                                        let l5 = *arg0
                                            .add(4 * ::core::mem::size_of::<*const u8>())
                                            .cast::<*mut u8>();
                                        let l6 = *arg0
                                            .add(5 * ::core::mem::size_of::<*const u8>())
                                            .cast::<usize>();
                                        let len7 = l6;
                                        let bytes7 = _rt::Vec::from_raw_parts(
                                            l5.cast(),
                                            len7,
                                            len7,
                                        );
                                        _rt::string_lift(bytes7)
                                    };
                                    Some(e)
                                }
                                _ => _rt::invalid_enum_discriminant(),
                            },
                            scopes: result13,
                            issuer: match l14 {
                                0 => None,
                                1 => {
                                    let e = {
                                        let l15 = *arg0
                                            .add(9 * ::core::mem::size_of::<*const u8>())
                                            .cast::<*mut u8>();
                                        let l16 = *arg0
                                            .add(10 * ::core::mem::size_of::<*const u8>())
                                            .cast::<usize>();
                                        let len17 = l16;
                                        let bytes17 = _rt::Vec::from_raw_parts(
                                            l15.cast(),
                                            len17,
                                            len17,
                                        );
                                        _rt::string_lift(bytes17)
                                    };
                                    Some(e)
                                }
                                _ => _rt::invalid_enum_discriminant(),
                            },
                            audience: match l18 {
                                0 => None,
                                1 => {
                                    let e = {
                                        let l19 = *arg0
                                            .add(12 * ::core::mem::size_of::<*const u8>())
                                            .cast::<*mut u8>();
                                        let l20 = *arg0
                                            .add(13 * ::core::mem::size_of::<*const u8>())
                                            .cast::<usize>();
                                        let len21 = l20;
                                        let bytes21 = _rt::Vec::from_raw_parts(
                                            l19.cast(),
                                            len21,
                                            len21,
                                        );
                                        _rt::string_lift(bytes21)
                                    };
                                    Some(e)
                                }
                                _ => _rt::invalid_enum_discriminant(),
                            },
                            claims: result30,
                            exp: match l31 {
                                0 => None,
                                1 => {
                                    let e = {
                                        let l32 = *arg0
                                            .add(8 + 16 * ::core::mem::size_of::<*const u8>())
                                            .cast::<i64>();
                                        l32 as u64
                                    };
                                    Some(e)
                                }
                                _ => _rt::invalid_enum_discriminant(),
                            },
                            iat: match l33 {
                                0 => None,
                                1 => {
                                    let e = {
                                        let l34 = *arg0
                                            .add(24 + 16 * ::core::mem::size_of::<*const u8>())
                                            .cast::<i64>();
                                        l34 as u64
                                    };
                                    Some(e)
                                }
                                _ => _rt::invalid_enum_discriminant(),
                            },
                        },
                        uri: _rt::string_lift(bytes37),
                        operation: ResourceOperation::_lift(l38 as u8),
                    });
                    _rt::cabi_dealloc(
                        arg0,
                        40 + 18 * ::core::mem::size_of::<*const u8>(),
                        8,
                    );
                    let ptr40 = (&raw mut _RET_AREA.0).cast::<u8>();
                    match result39 {
                        Ok(_) => {
                            *ptr40.add(0).cast::<u8>() = (0i32) as u8;
                        }
                        Err(e) => {
                            *ptr40.add(0).cast::<u8>() = (1i32) as u8;
                            let super::super::super::super::exports::fastertools::mcp::authorization::AuthError {
                                status: status41,
                                error_code: error_code41,
                                description: description41,
                                www_authenticate: www_authenticate41,
                            } = e;
                            *ptr40
                                .add(::core::mem::size_of::<*const u8>())
                                .cast::<u16>() = (_rt::as_i32(status41)) as u16;
                            let vec42 = (error_code41.into_bytes()).into_boxed_slice();
                            let ptr42 = vec42.as_ptr().cast::<u8>();
                            let len42 = vec42.len();
                            ::core::mem::forget(vec42);
                            *ptr40
                                .add(3 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>() = len42;
                            *ptr40
                                .add(2 * ::core::mem::size_of::<*const u8>())
                                .cast::<*mut u8>() = ptr42.cast_mut();
                            let vec43 = (description41.into_bytes()).into_boxed_slice();
                            let ptr43 = vec43.as_ptr().cast::<u8>();
                            let len43 = vec43.len();
                            ::core::mem::forget(vec43);
                            *ptr40
                                .add(5 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>() = len43;
                            *ptr40
                                .add(4 * ::core::mem::size_of::<*const u8>())
                                .cast::<*mut u8>() = ptr43.cast_mut();
                            match www_authenticate41 {
                                Some(e) => {
                                    *ptr40
                                        .add(6 * ::core::mem::size_of::<*const u8>())
                                        .cast::<u8>() = (1i32) as u8;
                                    let vec44 = (e.into_bytes()).into_boxed_slice();
                                    let ptr44 = vec44.as_ptr().cast::<u8>();
                                    let len44 = vec44.len();
                                    ::core::mem::forget(vec44);
                                    *ptr40
                                        .add(8 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len44;
                                    *ptr40
                                        .add(7 * ::core::mem::size_of::<*const u8>())
                                        .cast::<*mut u8>() = ptr44.cast_mut();
                                }
                                None => {
                                    *ptr40
                                        .add(6 * ::core::mem::size_of::<*const u8>())
                                        .cast::<u8>() = (0i32) as u8;
                                }
                            };
                        }
                    };
                    ptr40
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn __post_return_authorize_resource<T: Guest>(arg0: *mut u8) {
                    let l0 = i32::from(*arg0.add(0).cast::<u8>());
                    match l0 {
                        0 => {}
                        _ => {
                            let l1 = *arg0
                                .add(2 * ::core::mem::size_of::<*const u8>())
                                .cast::<*mut u8>();
                            let l2 = *arg0
                                .add(3 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>();
                            _rt::cabi_dealloc(l1, l2, 1);
                            let l3 = *arg0
                                .add(4 * ::core::mem::size_of::<*const u8>())
                                .cast::<*mut u8>();
                            let l4 = *arg0
                                .add(5 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>();
                            _rt::cabi_dealloc(l3, l4, 1);
                            let l5 = i32::from(
                                *arg0
                                    .add(6 * ::core::mem::size_of::<*const u8>())
                                    .cast::<u8>(),
                            );
                            match l5 {
                                0 => {}
                                _ => {
                                    let l6 = *arg0
                                        .add(7 * ::core::mem::size_of::<*const u8>())
                                        .cast::<*mut u8>();
                                    let l7 = *arg0
                                        .add(8 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l6, l7, 1);
                                }
                            }
                        }
                    }
                }
                pub trait Guest {
                    /// Authorize an MCP method call
                    fn authorize_method(
                        request: McpAuthRequest,
                    ) -> Result<(), AuthError>;
                    /// Authorize a specific tool call
                    fn authorize_tool(request: ToolAuthRequest) -> Result<(), AuthError>;
                    /// Authorize resource access
                    fn authorize_resource(
                        request: ResourceAuthRequest,
                    ) -> Result<(), AuthError>;
                }
                #[doc(hidden)]
                macro_rules! __export_fastertools_mcp_mcp_authorization_0_1_16_cabi {
                    ($ty:ident with_types_in $($path_to_types:tt)*) => {
                        const _ : () = { #[unsafe (export_name =
                        "fastertools:mcp/mcp-authorization@0.1.16#authorize-method")]
                        unsafe extern "C" fn export_authorize_method(arg0 : * mut u8,) ->
                        * mut u8 { unsafe { $($path_to_types)*::
                        _export_authorize_method_cabi::<$ty > (arg0) } } #[unsafe
                        (export_name =
                        "cabi_post_fastertools:mcp/mcp-authorization@0.1.16#authorize-method")]
                        unsafe extern "C" fn _post_return_authorize_method(arg0 : * mut
                        u8,) { unsafe { $($path_to_types)*::
                        __post_return_authorize_method::<$ty > (arg0) } } #[unsafe
                        (export_name =
                        "fastertools:mcp/mcp-authorization@0.1.16#authorize-tool")]
                        unsafe extern "C" fn export_authorize_tool(arg0 : * mut u8,) -> *
                        mut u8 { unsafe { $($path_to_types)*::
                        _export_authorize_tool_cabi::<$ty > (arg0) } } #[unsafe
                        (export_name =
                        "cabi_post_fastertools:mcp/mcp-authorization@0.1.16#authorize-tool")]
                        unsafe extern "C" fn _post_return_authorize_tool(arg0 : * mut
                        u8,) { unsafe { $($path_to_types)*::
                        __post_return_authorize_tool::<$ty > (arg0) } } #[unsafe
                        (export_name =
                        "fastertools:mcp/mcp-authorization@0.1.16#authorize-resource")]
                        unsafe extern "C" fn export_authorize_resource(arg0 : * mut u8,)
                        -> * mut u8 { unsafe { $($path_to_types)*::
                        _export_authorize_resource_cabi::<$ty > (arg0) } } #[unsafe
                        (export_name =
                        "cabi_post_fastertools:mcp/mcp-authorization@0.1.16#authorize-resource")]
                        unsafe extern "C" fn _post_return_authorize_resource(arg0 : * mut
                        u8,) { unsafe { $($path_to_types)*::
                        __post_return_authorize_resource::<$ty > (arg0) } } };
                    };
                }
                #[doc(hidden)]
                pub(crate) use __export_fastertools_mcp_mcp_authorization_0_1_16_cabi;
                #[cfg_attr(target_pointer_width = "64", repr(align(8)))]
                #[cfg_attr(target_pointer_width = "32", repr(align(4)))]
                struct _RetArea(
                    [::core::mem::MaybeUninit<
                        u8,
                    >; 9 * ::core::mem::size_of::<*const u8>()],
                );
                static mut _RET_AREA: _RetArea = _RetArea(
                    [::core::mem::MaybeUninit::uninit(); 9
                        * ::core::mem::size_of::<*const u8>()],
                );
            }
        }
    }
}
#[rustfmt::skip]
mod _rt {
    #![allow(dead_code, clippy::all)]
    pub use alloc_crate::string::String;
    pub use alloc_crate::vec::Vec;
    #[cfg(target_arch = "wasm32")]
    pub fn run_ctors_once() {
        wit_bindgen_rt::run_ctors_once();
    }
    pub unsafe fn string_lift(bytes: Vec<u8>) -> String {
        if cfg!(debug_assertions) {
            String::from_utf8(bytes).unwrap()
        } else {
            String::from_utf8_unchecked(bytes)
        }
    }
    pub unsafe fn cabi_dealloc(ptr: *mut u8, size: usize, align: usize) {
        if size == 0 {
            return;
        }
        let layout = alloc::Layout::from_size_align_unchecked(size, align);
        alloc::dealloc(ptr, layout);
    }
    pub unsafe fn invalid_enum_discriminant<T>() -> T {
        if cfg!(debug_assertions) {
            panic!("invalid enum discriminant")
        } else {
            unsafe { core::hint::unreachable_unchecked() }
        }
    }
    pub use alloc_crate::alloc;
    pub fn as_i64<T: AsI64>(t: T) -> i64 {
        t.as_i64()
    }
    pub trait AsI64 {
        fn as_i64(self) -> i64;
    }
    impl<'a, T: Copy + AsI64> AsI64 for &'a T {
        fn as_i64(self) -> i64 {
            (*self).as_i64()
        }
    }
    impl AsI64 for i64 {
        #[inline]
        fn as_i64(self) -> i64 {
            self as i64
        }
    }
    impl AsI64 for u64 {
        #[inline]
        fn as_i64(self) -> i64 {
            self as i64
        }
    }
    pub fn as_i32<T: AsI32>(t: T) -> i32 {
        t.as_i32()
    }
    pub trait AsI32 {
        fn as_i32(self) -> i32;
    }
    impl<'a, T: Copy + AsI32> AsI32 for &'a T {
        fn as_i32(self) -> i32 {
            (*self).as_i32()
        }
    }
    impl AsI32 for i32 {
        #[inline]
        fn as_i32(self) -> i32 {
            self as i32
        }
    }
    impl AsI32 for u32 {
        #[inline]
        fn as_i32(self) -> i32 {
            self as i32
        }
    }
    impl AsI32 for i16 {
        #[inline]
        fn as_i32(self) -> i32 {
            self as i32
        }
    }
    impl AsI32 for u16 {
        #[inline]
        fn as_i32(self) -> i32 {
            self as i32
        }
    }
    impl AsI32 for i8 {
        #[inline]
        fn as_i32(self) -> i32 {
            self as i32
        }
    }
    impl AsI32 for u8 {
        #[inline]
        fn as_i32(self) -> i32 {
            self as i32
        }
    }
    impl AsI32 for char {
        #[inline]
        fn as_i32(self) -> i32 {
            self as i32
        }
    }
    impl AsI32 for usize {
        #[inline]
        fn as_i32(self) -> i32 {
            self as i32
        }
    }
    pub unsafe fn bool_lift(val: u8) -> bool {
        if cfg!(debug_assertions) {
            match val {
                0 => false,
                1 => true,
                _ => panic!("invalid bool discriminant"),
            }
        } else {
            val != 0
        }
    }
    extern crate alloc as alloc_crate;
}
/// Generates `#[unsafe(no_mangle)]` functions to export the specified type as
/// the root implementation of all generated traits.
///
/// For more information see the documentation of `wit_bindgen::generate!`.
///
/// ```rust
/// # macro_rules! export{ ($($t:tt)*) => (); }
/// # trait Guest {}
/// struct MyType;
///
/// impl Guest for MyType {
///     // ...
/// }
///
/// export!(MyType);
/// ```
#[allow(unused_macros)]
#[doc(hidden)]
macro_rules! __export_authorization_provider_impl {
    ($ty:ident) => {
        self::export!($ty with_types_in self);
    };
    ($ty:ident with_types_in $($path_to_types_root:tt)*) => {
        $($path_to_types_root)*::
        exports::fastertools::mcp::authorization::__export_fastertools_mcp_authorization_0_1_16_cabi!($ty
        with_types_in $($path_to_types_root)*::
        exports::fastertools::mcp::authorization); $($path_to_types_root)*::
        exports::fastertools::mcp::jwt_validator::__export_fastertools_mcp_jwt_validator_0_1_16_cabi!($ty
        with_types_in $($path_to_types_root)*::
        exports::fastertools::mcp::jwt_validator); $($path_to_types_root)*::
        exports::fastertools::mcp::policy_engine::__export_fastertools_mcp_policy_engine_0_1_16_cabi!($ty
        with_types_in $($path_to_types_root)*::
        exports::fastertools::mcp::policy_engine); $($path_to_types_root)*::
        exports::fastertools::mcp::oauth_discovery::__export_fastertools_mcp_oauth_discovery_0_1_16_cabi!($ty
        with_types_in $($path_to_types_root)*::
        exports::fastertools::mcp::oauth_discovery); $($path_to_types_root)*::
        exports::fastertools::mcp::mcp_authorization::__export_fastertools_mcp_mcp_authorization_0_1_16_cabi!($ty
        with_types_in $($path_to_types_root)*::
        exports::fastertools::mcp::mcp_authorization);
    };
}
#[doc(inline)]
pub(crate) use __export_authorization_provider_impl as export;
#[cfg(target_arch = "wasm32")]
#[unsafe(
    link_section = "component-type:wit-bindgen:0.41.0:fastertools:mcp@0.1.16:authorization-provider:encoded world"
)]
#[doc(hidden)]
#[allow(clippy::octal_escapes)]
pub static __WIT_BINDGEN_COMPONENT_TYPE: [u8; 3837] = *b"\
\0asm\x0d\0\x01\0\0\x19\x16wit-component-encoding\x04\0\x07\xf0\x1c\x01A\x02\x01\
A\x11\x01B;\x01m\x02\x04user\x09assistant\x04\0\x04role\x03\0\0\x01s\x04\0\x0ajs\
on-value\x03\0\x02\x01o\x02ss\x01p\x04\x04\0\x0bmeta-fields\x03\0\x05\x01p\x01\x01\
k\x07\x01ku\x01ks\x01r\x03\x08audience\x08\x08priority\x09\x0dlast-modified\x0a\x04\
\0\x0bannotations\x03\0\x0b\x01r\x02\x04names\x05title\x0a\x04\0\x0dbase-metadat\
a\x03\0\x0d\x01k\x0c\x01k\x06\x01r\x03\x04texts\x0bannotations\x0f\x04meta\x10\x04\
\0\x0ctext-content\x03\0\x11\x01p}\x01r\x04\x04data\x13\x09mime-types\x0bannotat\
ions\x0f\x04meta\x10\x04\0\x0dimage-content\x03\0\x14\x01r\x04\x04data\x13\x09mi\
me-types\x0bannotations\x0f\x04meta\x10\x04\0\x0daudio-content\x03\0\x16\x01kw\x01\
r\x08\x03uris\x04names\x05title\x0a\x0bdescription\x0a\x09mime-type\x0a\x04size\x18\
\x0bannotations\x0f\x04meta\x10\x04\0\x0dresource-link\x03\0\x19\x01r\x04\x03uri\
s\x09mime-type\x0a\x04texts\x04meta\x10\x04\0\x16text-resource-contents\x03\0\x1b\
\x01r\x04\x03uris\x09mime-type\x0a\x04blob\x13\x04meta\x10\x04\0\x16blob-resourc\
e-contents\x03\0\x1d\x01q\x02\x04text\x01\x1c\0\x04blob\x01\x1e\0\x04\0\x11resou\
rce-contents\x03\0\x1f\x01r\x03\x08contents\x20\x0bannotations\x0f\x04meta\x10\x04\
\0\x11embedded-resource\x03\0!\x01q\x05\x04text\x01\x12\0\x05image\x01\x15\0\x05\
audio\x01\x17\0\x0dresource-link\x01\x1a\0\x11embedded-resource\x01\"\0\x04\0\x0d\
content-block\x03\0#\x01s\x04\0\x0bjson-schema\x03\0%\x01q\x0d\x0bparse-error\0\0\
\x0finvalid-request\0\0\x10method-not-found\0\0\x0einvalid-params\0\0\x0einterna\
l-error\0\0\x12resource-not-found\0\0\x0etool-not-found\0\0\x10prompt-not-found\0\
\0\x0cunauthorized\0\0\x0crate-limited\0\0\x07timeout\0\0\x09cancelled\0\0\x0bcu\
stom-code\x01z\0\x04\0\x0aerror-code\x03\0'\x01r\x03\x04code(\x07messages\x04dat\
a\x0a\x04\0\x09mcp-error\x03\0)\x01s\x04\0\x06cursor\x03\0+\x01s\x04\0\x0eprogre\
ss-token\x03\0-\x01q\x02\x03str\x01s\0\x03num\x01x\0\x04\0\x0arequest-id\x03\0/\x01\
m\x03\x04user\x09assistant\x06system\x04\0\x0cmessage-role\x03\01\x01r\x01\x04na\
me\x0a\x04\0\x0amodel-hint\x03\03\x01p4\x01k5\x01r\x04\x05hints6\x0dcost-priorit\
y\x09\x0espeed-priority\x09\x15intelligence-priority\x09\x04\0\x11model-preferen\
ces\x03\07\x01r\x04\x0curi-templates\x04names\x0bdescription\x0a\x09mime-type\x0a\
\x04\0\x11resource-template\x03\09\x03\0\x1cfastertools:mcp/types@0.1.16\x05\0\x02\
\x03\0\0\x09mcp-error\x02\x03\0\0\x0ajson-value\x02\x03\0\0\x0bmeta-fields\x01B\x17\
\x02\x03\x02\x01\x01\x04\0\x09mcp-error\x03\0\0\x02\x03\x02\x01\x02\x04\0\x0ajso\
n-value\x03\0\x02\x02\x03\x02\x01\x03\x04\0\x0bmeta-fields\x03\0\x04\x01ks\x01ps\
\x01kw\x01r\x08\x09client-id\x06\x07user-id\x06\x06scopes\x07\x06issuer\x06\x08a\
udience\x06\x06claims\x05\x03exp\x08\x03iat\x08\x04\0\x0cauth-context\x03\0\x09\x01\
o\x02ss\x01p\x0b\x01p}\x01k\x0d\x01r\x0a\x05tokens\x06methods\x04paths\x07header\
s\x0c\x04body\x0e\x0fexpected-issuers\x12expected-audiences\x07\x08jwks-uris\x06\
policy\x06\x0bpolicy-data\x06\x04\0\x0cauth-request\x03\0\x0f\x01r\x04\x06status\
{\x0aerror-codes\x0bdescriptions\x10www-authenticate\x06\x04\0\x0aauth-error\x03\
\0\x11\x01q\x02\x0aauthorized\x01\x0a\0\x0cunauthorized\x01\x12\0\x04\0\x0dauth-\
response\x03\0\x13\x01@\x01\x07request\x10\0\x14\x04\0\x09authorize\x01\x15\x04\0\
$fastertools:mcp/authorization@0.1.16\x05\x04\x01B\x16\x02\x03\x02\x01\x02\x04\0\
\x0ajson-value\x03\0\0\x01ps\x01ks\x01k\x7f\x01kw\x01r\x08\x05tokens\x0fexpected\
-issuers\x12expected-audiences\x02\x08jwks-uris\x09jwks-json\x03\x0cvalidate-exp\
\x04\x0cvalidate-nbf\x04\x0aclock-skew\x05\x04\0\x0bjwt-request\x03\0\x06\x01m\x0a\
\x09malformed\x11invalid-signature\x07expired\x0dnot-yet-valid\x0einvalid-issuer\
\x10invalid-audience\x0dmissing-claim\x0ajwks-error\x0bunknown-kid\x05other\x04\0\
\x09jwt-error\x03\0\x08\x01k\x02\x01o\x02s\x01\x01p\x0b\x01r\x0a\x03subs\x03isss\
\x03aud\x0a\x03exp\x05\x03iat\x05\x03nbf\x05\x03jti\x03\x06scopes\x02\x09client-\
id\x03\x11additional-claims\x0c\x04\0\x0ajwt-claims\x03\0\x0d\x01q\x02\x05valid\x01\
\x0e\0\x07invalid\x01\x09\0\x04\0\x0ajwt-result\x03\0\x0f\x01@\x01\x07request\x07\
\0\x10\x04\0\x08validate\x01\x11\x01j\x01s\x01s\x01@\x01\x03uris\0\x12\x04\0\x0a\
fetch-jwks\x01\x13\x04\0$fastertools:mcp/jwt-validator@0.1.16\x05\x05\x01B\x0a\x02\
\x03\x02\x01\x02\x04\0\x0ajson-value\x03\0\0\x01k\x01\x01ks\x01r\x04\x06policys\x04\
data\x02\x05input\x01\x05query\x03\x04\0\x0epolicy-request\x03\0\x04\x01q\x03\x05\
allow\0\0\x04deny\x01s\0\x05error\x01s\0\x04\0\x0dpolicy-result\x03\0\x06\x01@\x01\
\x07request\x05\0\x07\x04\0\x08evaluate\x01\x08\x04\0$fastertools:mcp/policy-eng\
ine@0.1.16\x05\x06\x01B\x0b\x01ps\x01k\0\x01ks\x01r\x05\x0cresource-urls\x15auth\
orization-servers\0\x10scopes-supported\x01\x18bearer-methods-supported\x01\x16r\
esource-documentation\x02\x04\0\x11resource-metadata\x03\0\x03\x01r\x0b\x06issue\
rs\x16authorization-endpoints\x0etoken-endpoints\x08jwks-uris\x18response-types-\
supported\0\x15grant-types-supported\0\x20code-challenge-methods-supported\0\x10\
scopes-supported\x01%token-endpoint-auth-methods-supported\x01\x15service-docume\
ntation\x02\x15registration-endpoint\x02\x04\0\x0fserver-metadata\x03\0\x05\x01@\
\0\0\x04\x04\0\x15get-resource-metadata\x01\x07\x01@\0\0\x06\x04\0\x13get-server\
-metadata\x01\x08\x04\0&fastertools:mcp/oauth-discovery@0.1.16\x05\x07\x02\x03\0\
\x01\x0cauth-context\x02\x03\0\x01\x0aauth-error\x01B\x16\x02\x03\x02\x01\x08\x04\
\0\x0cauth-context\x03\0\0\x02\x03\x02\x01\x09\x04\0\x0aauth-error\x03\0\x02\x02\
\x03\x02\x01\x02\x04\0\x0ajson-value\x03\0\x04\x01k\x05\x01r\x03\x07context\x01\x06\
methods\x06params\x06\x04\0\x10mcp-auth-request\x03\0\x07\x01r\x03\x07context\x01\
\x09tool-names\x09arguments\x06\x04\0\x11tool-auth-request\x03\0\x09\x01m\x04\x07\
list-op\x07read-op\x0csubscribe-op\x0eunsubscribe-op\x04\0\x12resource-operation\
\x03\0\x0b\x01r\x03\x07context\x01\x03uris\x09operation\x0c\x04\0\x15resource-au\
th-request\x03\0\x0d\x01j\0\x01\x03\x01@\x01\x07request\x08\0\x0f\x04\0\x10autho\
rize-method\x01\x10\x01@\x01\x07request\x0a\0\x0f\x04\0\x0eauthorize-tool\x01\x11\
\x01@\x01\x07request\x0e\0\x0f\x04\0\x12authorize-resource\x01\x12\x04\0(fastert\
ools:mcp/mcp-authorization@0.1.16\x05\x0a\x04\0-fastertools:mcp/authorization-pr\
ovider@0.1.16\x04\0\x0b\x1c\x01\0\x16authorization-provider\x03\0\0\0G\x09produc\
ers\x01\x0cprocessed-by\x02\x0dwit-component\x070.227.1\x10wit-bindgen-rust\x060\
.41.0";
#[inline(never)]
#[doc(hidden)]
pub fn __link_custom_section_describing_imports() {
    wit_bindgen_rt::maybe_link_cabi_realloc();
}
