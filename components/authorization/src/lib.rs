mod jwt;
mod policy;
mod discovery;
mod mcp;
mod config;

use config::{get_config, ConfigKeys};

// Component bindings will be generated here
#[allow(warnings)]
mod bindings;

// Note: bindings are now auto-generated by cargo-component

use bindings::exports::fastertools::mcp::{
    authorization::{
        AuthContext, AuthError as WitAuthError, AuthRequest, AuthResponse, Guest as AuthGuest,
    },
    jwt_validator::{
        Guest as JwtGuest, JwtError, JwtRequest, JwtResult,
    },
    mcp_authorization::{
        Guest as McpAuthGuest, McpAuthRequest, ResourceAuthRequest,
        ToolAuthRequest,
    },
    oauth_discovery::{Guest as OAuthGuest, ResourceMetadata, ServerMetadata},
    policy_engine::{Guest as PolicyGuest, PolicyRequest, PolicyResult},
};

// JsonValue and MetaFields are now strings in the bindings

/// Main component struct
struct Component;

/// Authorization implementation
impl AuthGuest for Component {
    fn authorize(request: AuthRequest) -> AuthResponse {
        // Get configuration from WASI config runtime
        // Use values from request as fallback if not configured
        let expected_issuer = get_config(ConfigKeys::EXPECTED_ISSUER)
            .or(request.expected_issuer.clone())
            .or_else(|| Some("https://test.example.com/".to_string()));
        let expected_audience = get_config(ConfigKeys::EXPECTED_AUDIENCE)
            .or(request.expected_audience.clone())
            .or_else(|| Some("https://mcp.example.com".to_string()));
        let jwks_uri = get_config(ConfigKeys::JWKS_URI)
            .or(request.jwks_uri.clone());
        
        // Get validation leeway from config (default to 60 seconds)
        let clock_skew = get_config(ConfigKeys::VALIDATION_LEEWAY)
            .and_then(|s| s.parse::<u64>().ok())
            .unwrap_or(60);
        
        // First validate the JWT token
        let jwt_request = JwtRequest {
            token: request.token.clone(),
            expected_issuer,
            expected_audience,
            jwks_uri,
            jwks_json: None,
            validate_exp: Some(true),
            validate_nbf: Some(true),
            clock_skew: Some(clock_skew),
        };

        let jwt_result = jwt::validate(jwt_request);
        
        let claims = match jwt_result {
            JwtResult::Valid(claims) => claims,
            JwtResult::Invalid(error) => {
                return AuthResponse::Unauthorized(WitAuthError {
                    status: 401,
                    error_code: "invalid_token".to_string(),
                    description: format!("JWT validation failed: {:?}", error),
                    www_authenticate: Some(build_www_authenticate(&error)),
                });
            }
        };

        // Extract auth context from validated claims
        let auth_context = AuthContext {
            client_id: claims.client_id.clone(),
            user_id: Some(claims.sub.clone()),
            scopes: claims.scopes.clone(),
            issuer: Some(claims.iss.clone()),
            audience: claims.aud.as_ref().and_then(|a| a.first().cloned()),
            claims: convert_claims_to_meta(&claims.additional_claims),
            exp: claims.exp,
            iat: claims.iat,
        };

        // Apply policy-based authorization if we have a body
        if let Some(body) = request.body {
            // Parse the body as JSON-RPC for MCP context
            if let Ok(json_str) = std::str::from_utf8(&body) {
                if let Ok(json_value) = serde_json::from_str::<serde_json::Value>(json_str) {
                    // Build policy input
                    let policy_input = serde_json::json!({
                        "token": {
                            "sub": claims.sub,
                            "iss": claims.iss,
                            "aud": claims.aud.clone(),
                            "scopes": claims.scopes,
                            "client_id": claims.client_id,
                        },
                        "request": {
                            "method": request.method,
                            "path": request.path,
                            "headers": headers_to_object(&request.headers),
                        },
                        "mcp": parse_mcp_context(&json_value),
                    });

                    // Check if we have a policy configured (via environment or default)
                    if let Some(policy) = get_configured_policy() {
                        let policy_request = PolicyRequest {
                            policy,
                            data: get_configured_policy_data(),
                            input: serde_json::to_string(&policy_input).unwrap(),
                            query: Some("data.mcp.authorization.allow".to_string()),
                        };

                        match policy::evaluate(policy_request) {
                            PolicyResult::Allow => {
                                // Policy allowed, continue
                            }
                            PolicyResult::Deny(reason) => {
                                return AuthResponse::Unauthorized(WitAuthError {
                                    status: 403,
                                    error_code: "insufficient_scope".to_string(),
                                    description: format!("Authorization denied: {}", reason),
                                    www_authenticate: None,
                                });
                            }
                            PolicyResult::Error(err) => {
                                return AuthResponse::Unauthorized(WitAuthError {
                                    status: 500,
                                    error_code: "server_error".to_string(),
                                    description: format!("Policy evaluation failed: {}", err),
                                    www_authenticate: None,
                                });
                            }
                        }
                    }
                }
            }
        }

        AuthResponse::Authorized(auth_context)
    }
}

/// JWT Validator implementation
impl JwtGuest for Component {
    fn validate(request: JwtRequest) -> JwtResult {
        jwt::validate(request)
    }

    fn fetch_jwks(uri: String) -> Result<String, String> {
        jwt::fetch_jwks(&uri)
    }
}

/// Policy Engine implementation
impl PolicyGuest for Component {
    fn evaluate(request: PolicyRequest) -> PolicyResult {
        policy::evaluate(request)
    }
}

/// OAuth Discovery implementation
impl OAuthGuest for Component {
    fn get_resource_metadata() -> ResourceMetadata {
        discovery::get_resource_metadata()
    }

    fn get_server_metadata() -> ServerMetadata {
        discovery::get_server_metadata()
    }
}

/// MCP Authorization implementation
impl McpAuthGuest for Component {
    fn authorize_method(
        request: McpAuthRequest,
    ) -> Result<(), WitAuthError> {
        mcp::authorize_method(request)
    }

    fn authorize_tool(
        request: ToolAuthRequest,
    ) -> Result<(), WitAuthError> {
        mcp::authorize_tool(request)
    }

    fn authorize_resource(
        request: ResourceAuthRequest,
    ) -> Result<(), WitAuthError> {
        mcp::authorize_resource(request)
    }
}

// Helper functions

fn build_www_authenticate(error: &JwtError) -> String {
    let error_code = match error {
        JwtError::Expired => "invalid_token",
        JwtError::InvalidSignature => "invalid_token",
        JwtError::InvalidIssuer => "invalid_token",
        JwtError::InvalidAudience => "invalid_token",
        _ => "invalid_token",
    };
    
    let description = match error {
        JwtError::Expired => "Token has expired",
        JwtError::InvalidSignature => "Invalid token signature",
        JwtError::InvalidIssuer => "Invalid token issuer",
        JwtError::InvalidAudience => "Invalid token audience",
        JwtError::Malformed => "Malformed token",
        JwtError::NotYetValid => "Token not yet valid",
        JwtError::MissingClaim => "Required claim missing",
        JwtError::JwksError => "JWKS validation error",
        JwtError::UnknownKid => "Unknown key ID",
        JwtError::Other => "Token validation failed",
    };
    
    format!(r#"Bearer error="{}", error_description="{}""#, error_code, description)
}

fn convert_claims_to_meta(claims: &[(String, String)]) -> Vec<(String, String)> {
    claims.to_vec()
}

fn headers_to_object(headers: &[(String, String)]) -> serde_json::Value {
    let mut map = serde_json::Map::new();
    for (key, value) in headers {
        map.insert(key.clone(), serde_json::Value::String(value.clone()));
    }
    serde_json::Value::Object(map)
}

fn parse_mcp_context(json: &serde_json::Value) -> serde_json::Value {
    if let Some(method) = json.get("method").and_then(|m| m.as_str()) {
        let mut context = serde_json::json!({
            "method": method,
        });
        
        if method == "tools/call" {
            if let Some(params) = json.get("params") {
                if let Some(name) = params.get("name") {
                    context["tool"] = name.clone();
                }
                if let Some(args) = params.get("arguments") {
                    context["arguments"] = args.clone();
                }
            }
        }
        
        context
    } else {
        serde_json::json!({})
    }
}

fn get_configured_policy() -> Option<String> {
    // Check policy mode from config
    let mode = get_config(ConfigKeys::POLICY_MODE).unwrap_or_else(|| "default".to_string());
    
    match mode.as_str() {
        "none" => None, // No policy enforcement
        "custom" => {
            // Custom policy mode - requires policy to be provided via config
            // Note: In a component model environment, we cannot read files directly
            // The policy must be provided as a configuration value
            if let Some(policy_content) = get_config(ConfigKeys::POLICY_CONTENT) {
                Some(policy_content)
            } else {
                eprintln!("Custom policy mode requires 'policy.content' configuration");
                eprintln!("Falling back to default permissive policy");
                // Fall back to default permissive policy
                Some(r#"
                    package mcp.authorization
                    
                    # Default to allow for authenticated users
                    default allow = true
                "#.to_string())
            }
        }
        "rbac" => {
            // Return RBAC policy
            Some(r#"
                package mcp.authorization
                
                default allow = false
                
                # RBAC-based authorization
                allow if {
                    input.token.scopes[_] == "admin"
                }
                
                allow if {
                    input.mcp.method == "tools/list"
                    input.token.scopes[_] == "read"
                }
                
                allow if {
                    input.mcp.method == "tools/call"
                    input.token.scopes[_] == "execute"
                }
            "#.to_string())
        }
        _ => {
            // Default permissive policy - allow all authenticated users
            Some(r#"
                package mcp.authorization
                
                # Default to allow for authenticated users
                default allow = true
                
                # This permissive policy allows all authenticated requests
                # The JWT validation already ensures:
                # - Valid signature from JWKS
                # - Correct issuer
                # - Correct audience
                # - Not expired
                # If you need more restrictions, set policy.mode to "rbac" or "custom"
            "#.to_string())
        }
    }
}

fn get_configured_policy_data() -> Option<String> {
    // Optional external data for policy evaluation
    None
}

// Export the component - this generates the WebAssembly exports
bindings::export!(Component with_types_in bindings);

