package fastertools:mcp@0.1.0;

/// Core type definitions for the Model Context Protocol
/// These types are used across all MCP interfaces
interface types {
  /// Role in a conversation
  enum role {
    user,
    assistant,
  }

  /// Extensible metadata fields for forward compatibility
  type meta-fields = list<tuple<string, string>>;

  /// Annotations provide hints to clients about how to handle data
  record annotations {
    /// Who this data is intended for
    audience: option<list<role>>,
    /// Priority from 0.0 (least) to 1.0 (most important)
    priority: option<f64>,
    /// ISO 8601 timestamp of last modification
    last-modified: option<string>,
  }

  /// Base metadata pattern used throughout the protocol
  record base-metadata {
    /// Programmatic identifier
    name: string,
    /// Human-readable display name
    title: option<string>,
  }

  /// Text content with optional annotations
  record text-content {
    text: string,
    annotations: option<annotations>,
    meta: option<meta-fields>,
  }

  /// Image content as binary data
  record image-content {
    /// Base64-encoded image data
    data: list<u8>,
    /// MIME type (e.g., "image/png", "image/jpeg")
    mime-type: string,
    annotations: option<annotations>,
    meta: option<meta-fields>,
  }

  /// Audio content as binary data
  record audio-content {
    /// Base64-encoded audio data
    data: list<u8>,
    /// MIME type (e.g., "audio/wav", "audio/mp3")
    mime-type: string,
    annotations: option<annotations>,
    meta: option<meta-fields>,
  }

  /// Reference to a resource
  record resource-link {
    uri: string,
    name: string,
    description: option<string>,
    mime-type: option<string>,
    size: option<u64>,
    annotations: option<annotations>,
    meta: option<meta-fields>,
  }

  record text-resource-contents {
    uri: string,
    mime-type: option<string>,
    text: string,
    meta: option<meta-fields>,
  }

  record blob-resource-contents {
    uri: string,
    mime-type: option<string>,
    /// Binary data
    blob: list<u8>,
    meta: option<meta-fields>,
  }

  /// Resource contents can be either text or binary
  variant resource-contents {
    text(text-resource-contents),
    blob(blob-resource-contents),
  }

  /// Embedded resource content
  record embedded-resource {
    contents: resource-contents,
    annotations: option<annotations>,
    meta: option<meta-fields>,
  }

  /// Content block types that can be included in messages
  variant content-block {
    text(text-content),
    image(image-content),
    audio(audio-content),
    resource-link(resource-link),
    embedded-resource(embedded-resource),
  }

  /// JSON value representation as a string
  /// WIT doesn't support recursive types, so we serialize JSON as strings
  /// The string should contain valid JSON that can be parsed/serialized
  type json-value = string;

  /// Standard JSON-RPC and MCP error codes
  variant error-code {
    /// JSON-RPC standard errors
    parse-error,
    /// -32700
    invalid-request,
    /// -32600
    method-not-found,
    /// -32601
    invalid-params,
    /// -32602
    internal-error,
    /// -32603
    /// MCP-specific errors
    resource-not-found,
    tool-not-found,
    prompt-not-found,
    unauthorized,
    rate-limited,
    timeout,
    cancelled,
    /// Custom error with specific code
    custom-code(s32),
  }

  /// Standard error structure
  record mcp-error {
    code: error-code,
    message: string,
    /// Additional error context
    data: option<json-value>,
  }

  /// Pagination cursor for list operations
  type cursor = string;

  /// Progress token for tracking long-running operations
  type progress-token = string;
}

/// Notification system for MCP events and updates
interface notifications {
  use types.{mcp-error, meta-fields, progress-token};

  /// Notification types that can be sent
  /// Notification that a long-running operation has progress
  record progress-notification {
    /// Token identifying the operation
    progress-token: progress-token,
    /// Current progress value
    progress: u32,
    /// Total expected progress (if known)
    total: option<u32>,
    /// Optional progress message
    message: option<string>,
    /// Extension metadata
    meta: option<meta-fields>,
  }

  /// Notification that an operation was cancelled
  record cancelled-notification {
    /// ID of the cancelled request
    request-id: string,
    /// Optional cancellation reason
    reason: option<string>,
    /// Extension metadata
    meta: option<meta-fields>,
  }

  /// Notification that the tools list has changed
  record tools-list-changed {
    /// Extension metadata
    meta: option<meta-fields>,
  }

  /// Notification that the resources list has changed
  record resources-list-changed {
    /// Extension metadata
    meta: option<meta-fields>,
  }

  /// Notification that the prompts list has changed
  record prompts-list-changed {
    /// Extension metadata
    meta: option<meta-fields>,
  }

  /// Notification that a subscribed resource has been updated
  record resource-updated {
    /// URI of the updated resource
    uri: string,
    /// Extension metadata
    meta: option<meta-fields>,
  }

  /// Notification that the roots list has changed
  record roots-list-changed {
    /// Extension metadata
    meta: option<meta-fields>,
  }

  /// Log levels for logging notifications
  enum log-level {
    debug,
    info,
    notice,
    warning,
    error,
    critical,
    alert,
    emergency,
  }

  /// Log message notification
  record log-message {
    /// Severity level
    level: log-level,
    /// Optional logger name
    logger: option<string>,
    /// Log message or data
    message: string,
    /// Additional structured data
    data: option<list<tuple<string, string>>>,
    /// Extension metadata
    meta: option<meta-fields>,
  }

  /// All possible notification types
  variant notification {
    /// Progress update for long-running operation
    progress(progress-notification),
    /// Operation was cancelled
    cancelled(cancelled-notification),
    /// Tools list changed
    tools-list-changed(tools-list-changed),
    /// Resources list changed
    resources-list-changed(resources-list-changed),
    /// Prompts list changed
    prompts-list-changed(prompts-list-changed),
    /// Subscribed resource was updated
    resource-updated(resource-updated),
    /// Roots list changed
    roots-list-changed(roots-list-changed),
    /// Log message from server
    log-message(log-message),
  }

  /// Notification operations
  /// Send a notification to the client
  send-notification: func(notification: notification) -> result<_, mcp-error>;

  /// Set the minimum log level for log notifications
  set-log-level: func(level: log-level) -> result<_, mcp-error>;
}

/// Prompt template discovery and rendering for MCP
interface prompts {
  use types.{role, content-block, mcp-error, base-metadata, meta-fields, cursor, progress-token};

  /// Argument definition for a prompt template
  record prompt-argument {
    /// Base metadata (name and optional title)
    base: base-metadata,
    /// Human-readable description
    description: option<string>,
    /// Whether this argument is required
    required: option<bool>,
  }

  /// Prompt template definition
  record prompt {
    /// Base metadata (name and optional title)
    base: base-metadata,
    /// Description of what this prompt does
    description: option<string>,
    /// Arguments that can be passed to the prompt
    arguments: option<list<prompt-argument>>,
    /// Extension metadata
    meta: option<meta-fields>,
  }

  /// Message in a prompt conversation
  record prompt-message {
    /// Who is speaking (user or assistant)
    role: role,
    /// Message content
    content: content-block,
  }

  /// Request to list available prompts
  record list-prompts-request {
    /// Pagination cursor
    cursor: option<cursor>,
    /// Progress tracking token
    progress-token: option<progress-token>,
    /// Extension metadata
    meta: option<meta-fields>,
  }

  /// Response with list of prompts
  record list-prompts-response {
    /// Available prompts
    prompts: list<prompt>,
    /// Cursor for next page
    next-cursor: option<cursor>,
    /// Extension metadata
    meta: option<meta-fields>,
  }

  /// Request to get a specific prompt
  record get-prompt-request {
    /// Name of the prompt to retrieve
    name: string,
    /// Arguments for template substitution
    arguments: option<list<tuple<string, string>>>,
    /// Progress tracking token
    progress-token: option<progress-token>,
    /// Extension metadata
    meta: option<meta-fields>,
  }

  /// Response with rendered prompt messages
  record get-prompt-response {
    /// Optional description of the rendered prompt
    description: option<string>,
    /// Messages that make up the prompt
    messages: list<prompt-message>,
    /// Extension metadata
    meta: option<meta-fields>,
  }

  /// Prompt operations
  /// List available prompts with pagination
  list-prompts: func(request: list-prompts-request) -> result<list-prompts-response, mcp-error>;

  /// Get a specific prompt with optional arguments
  get-prompt: func(request: get-prompt-request) -> result<get-prompt-response, mcp-error>;
}

/// Resource discovery, reading, and subscription for MCP
interface resources {
  use types.{mcp-error, base-metadata, annotations, meta-fields, cursor, resource-contents, progress-token};

  /// A resource that can be read by the client
  record mcp-resource {
    /// Base metadata (name and optional title)
    base: base-metadata,
    /// URI identifying the resource
    uri: string,
    /// Human-readable description
    description: option<string>,
    /// MIME type if known
    mime-type: option<string>,
    /// Size in bytes (before encoding)
    size: option<u64>,
    /// Client hints
    annotations: option<annotations>,
    /// Extension metadata
    meta: option<meta-fields>,
  }

  /// Template for constructing resource URIs
  record resource-template {
    /// Base metadata (name and optional title)
    base: base-metadata,
    /// URI template (RFC 6570)
    uri-template: string,
    /// Description of what this template provides
    description: option<string>,
    /// MIME type for all matching resources
    mime-type: option<string>,
    /// Client hints
    annotations: option<annotations>,
    /// Extension metadata
    meta: option<meta-fields>,
  }

  /// Request to list available resources
  record list-resources-request {
    /// Pagination cursor
    cursor: option<cursor>,
    /// Progress tracking token
    progress-token: option<progress-token>,
    /// Extension metadata
    meta: option<meta-fields>,
  }

  /// Response with list of resources
  record list-resources-response {
    /// Available resources
    resources: list<mcp-resource>,
    /// Cursor for next page
    next-cursor: option<cursor>,
    /// Extension metadata
    meta: option<meta-fields>,
  }

  /// Request to list resource templates
  record list-templates-request {
    /// Pagination cursor
    cursor: option<cursor>,
    /// Progress tracking token
    progress-token: option<progress-token>,
    /// Extension metadata
    meta: option<meta-fields>,
  }

  /// Response with list of resource templates
  record list-templates-response {
    /// Available templates
    templates: list<resource-template>,
    /// Cursor for next page
    next-cursor: option<cursor>,
    /// Extension metadata
    meta: option<meta-fields>,
  }

  /// Request to read a specific resource
  record read-resource-request {
    /// URI of the resource to read
    uri: string,
    /// Progress tracking token
    progress-token: option<progress-token>,
    /// Extension metadata
    meta: option<meta-fields>,
  }

  /// Response with resource contents
  record read-resource-response {
    /// Resource contents (may be multiple for sub-resources)
    contents: list<resource-contents>,
    /// Extension metadata
    meta: option<meta-fields>,
  }

  /// Request to subscribe to resource updates
  record subscribe-request {
    /// URI of the resource to monitor
    uri: string,
    /// Extension metadata
    meta: option<meta-fields>,
  }

  /// Request to unsubscribe from resource updates
  record unsubscribe-request {
    /// URI of the resource to stop monitoring
    uri: string,
    /// Extension metadata
    meta: option<meta-fields>,
  }

  /// Resource operations
  /// List available resources with pagination
  list-resources: func(request: list-resources-request) -> result<list-resources-response, mcp-error>;

  /// List available resource templates
  list-resource-templates: func(request: list-templates-request) -> result<list-templates-response, mcp-error>;

  /// Read the contents of a specific resource
  read-resource: func(request: read-resource-request) -> result<read-resource-response, mcp-error>;

  /// Subscribe to updates for a resource
  subscribe-resource: func(request: subscribe-request) -> result<_, mcp-error>;

  /// Unsubscribe from resource updates
  unsubscribe-resource: func(request: unsubscribe-request) -> result<_, mcp-error>;
}

/// Session management and capability negotiation for MCP
interface session {
  use types.{mcp-error, meta-fields};

  /// Protocol version constants
  /// Current draft version: "DRAFT-2025-v3"
  type protocol-version = string;

  /// Information about an MCP implementation
  record implementation-info {
    /// Implementation name (e.g., "weather-server")
    name: string,
    /// Implementation version (e.g., "1.0.0")
    version: string,
    /// Optional human-readable title
    title: option<string>,
  }

  /// Root listing capability details
  record roots-capability {
    /// Server will notify when roots list changes
    list-changed: option<bool>,
  }

  /// Capabilities that a client supports
  record client-capabilities {
    /// Experimental/custom capabilities
    experimental: option<meta-fields>,
    /// Support for roots (directory access)
    roots: option<roots-capability>,
    /// Support for LLM sampling
    sampling: option<bool>,
    /// Support for user elicitation
    elicitation: option<bool>,
  }

  /// Prompts capability details
  record prompts-capability {
    /// Server will notify when prompts list changes
    list-changed: option<bool>,
  }

  /// Resources capability details
  record resources-capability {
    /// Server supports resource subscriptions
    subscribe: option<bool>,
    /// Server will notify when resource list changes
    list-changed: option<bool>,
  }

  /// Tools capability details
  record tools-capability {
    /// Server will notify when tools list changes
    list-changed: option<bool>,
  }

  /// Capabilities that a server provides
  record server-capabilities {
    /// Experimental/custom capabilities
    experimental: option<meta-fields>,
    /// Server can send log messages
    logging: option<bool>,
    /// Server supports argument autocompletion
    completions: option<bool>,
    /// Server offers prompts
    prompts: option<prompts-capability>,
    /// Server offers resources
    resources: option<resources-capability>,
    /// Server offers tools
    tools: option<tools-capability>,
  }

  /// Initialize request sent by client on connection
  record initialize-request {
    /// Protocol version the client supports
    protocol-version: protocol-version,
    /// Client's capabilities
    capabilities: client-capabilities,
    /// Client implementation details
    client-info: implementation-info,
    /// Optional metadata
    meta: option<meta-fields>,
  }

  /// Initialize response from server
  record initialize-response {
    /// Protocol version the server will use
    protocol-version: protocol-version,
    /// Server's capabilities
    capabilities: server-capabilities,
    /// Server implementation details
    server-info: implementation-info,
    /// Optional instructions for using the server
    instructions: option<string>,
    /// Optional metadata
    meta: option<meta-fields>,
  }

  /// Session lifecycle operations
  /// Initialize the MCP session
  initialize: func(request: initialize-request) -> result<initialize-response, mcp-error>;

  /// Notify server that initialization is complete
  initialized: func() -> result<_, mcp-error>;

  /// Ping to check if connection is alive
  ping: func() -> result<_, mcp-error>;

  /// Shutdown the session gracefully
  shutdown: func() -> result<_, mcp-error>;
}

/// Tool discovery and execution for MCP
interface tools {
  use types.{content-block, json-value, mcp-error, base-metadata, meta-fields, cursor, progress-token};

  /// Behavioral hints about tool operations
  record tool-annotations {
    /// Human-readable title for display
    title: option<string>,
    /// Tool does not modify environment
    read-only-hint: option<bool>,
    /// Tool may perform destructive updates (meaningful when not read-only)
    destructive-hint: option<bool>,
    /// Repeated calls with same args have no additional effect
    idempotent-hint: option<bool>,
    /// Tool interacts with external entities
    open-world-hint: option<bool>,
  }

  /// JSON Schema representation for tool parameters
  /// The schema is provided as a JSON string to handle complex nested schemas
  type json-schema = json-value;

  /// Tool definition with metadata and schema
  record tool {
    /// Base metadata (name and optional title)
    base: base-metadata,
    /// Human-readable description of what the tool does
    description: option<string>,
    /// JSON Schema for input parameters
    input-schema: json-schema,
    /// Optional schema for structured output
    output-schema: option<json-schema>,
    /// Behavioral hints for clients
    annotations: option<tool-annotations>,
    /// Extension metadata
    meta: option<meta-fields>,
  }

  /// Result from executing a tool
  record tool-result {
    /// Unstructured content blocks (text, images, etc.)
    content: list<content-block>,
    /// Optional structured JSON output
    structured-content: option<json-value>,
    /// Whether the tool execution resulted in an error
    /// If true, content should contain error details
    is-error: option<bool>,
    /// Extension metadata
    meta: option<meta-fields>,
  }

  /// Request to list available tools
  record list-tools-request {
    /// Pagination cursor from previous response
    cursor: option<cursor>,
    /// Optional progress tracking token
    progress-token: option<progress-token>,
    /// Extension metadata
    meta: option<meta-fields>,
  }

  /// Response with list of available tools
  record list-tools-response {
    /// Available tools
    tools: list<tool>,
    /// Cursor for next page if more tools exist
    next-cursor: option<cursor>,
    /// Extension metadata
    meta: option<meta-fields>,
  }

  /// Request to execute a tool
  record call-tool-request {
    /// Name of the tool to execute
    name: string,
    /// Arguments as JSON object
    arguments: option<json-value>,
    /// Optional progress tracking token
    progress-token: option<progress-token>,
    /// Extension metadata
    meta: option<meta-fields>,
  }

  /// Tool operations
  /// List available tools with optional pagination
  list-tools: func(request: list-tools-request) -> result<list-tools-response, mcp-error>;

  /// Execute a tool with the provided arguments
  call-tool: func(request: call-tool-request) -> result<tool-result, mcp-error>;
}

/// Main handler interface that MCP implementations must provide
interface handler {
  use types.{mcp-error};
  use session.{initialize-request, initialize-response};
  use tools.{list-tools-request, list-tools-response, call-tool-request, tool-result};
  use resources.{list-resources-request, list-resources-response, list-templates-request, list-templates-response, read-resource-request, read-resource-response, subscribe-request, unsubscribe-request};
  use prompts.{list-prompts-request, list-prompts-response, get-prompt-request, get-prompt-response};

  /// Core handler functions that implementations must provide
  /// Handle session initialization
  handle-initialize: func(request: initialize-request) -> result<initialize-response, mcp-error>;

  /// Handle initialization complete notification
  handle-initialized: func() -> result<_, mcp-error>;

  /// Handle ping request
  handle-ping: func() -> result<_, mcp-error>;

  /// Handle shutdown request
  handle-shutdown: func() -> result<_, mcp-error>;

  /// Tool operations
  handle-list-tools: func(request: list-tools-request) -> result<list-tools-response, mcp-error>;

  handle-call-tool: func(request: call-tool-request) -> result<tool-result, mcp-error>;

  /// Resource operations
  handle-list-resources: func(request: list-resources-request) -> result<list-resources-response, mcp-error>;

  handle-list-resource-templates: func(request: list-templates-request) -> result<list-templates-response, mcp-error>;

  handle-read-resource: func(request: read-resource-request) -> result<read-resource-response, mcp-error>;

  handle-subscribe-resource: func(request: subscribe-request) -> result<_, mcp-error>;

  handle-unsubscribe-resource: func(request: unsubscribe-request) -> result<_, mcp-error>;

  /// Prompt operations
  handle-list-prompts: func(request: list-prompts-request) -> result<list-prompts-response, mcp-error>;

  handle-get-prompt: func(request: get-prompt-request) -> result<get-prompt-response, mcp-error>;
}

