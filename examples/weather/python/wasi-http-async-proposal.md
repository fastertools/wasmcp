# wasi-http-async Library Proposal

## Problem Statement
Currently, Python developers using WASI HTTP must copy 200+ lines of boilerplate code (async event loop, stream handling, resource cleanup) to make HTTP requests in WebAssembly components. This creates maintenance burden and raises the barrier to entry.

## Solution
Create a `wasi-http-async` library that provides a simple, fetch-like API for HTTP requests in WASI components.

## Design Goals
- **Simple API**: Mirror JavaScript's familiar fetch() API
- **Zero Configuration**: Work out-of-the-box with componentize-py
- **Standards Compliant**: Pure WASI underneath, no framework dependencies
- **Both Async/Sync**: Support both programming patterns
- **Future-Proof**: Easy migration path to WASI Preview 3's native async

## API Example

### Primary API - Direct Import
```python
from wasi_http_async import fetch, fetch_sync

# Async usage
async def get_weather(city: str):
    response = await fetch(f"https://api.example.com/weather?city={city}")
    return await response.json()

# Sync usage
def get_weather_sync(city: str):
    response = fetch_sync(f"https://api.example.com/weather?city={city}")
    return response.json()
```

### Transparent HTTP Support Options

#### Option A: urllib Patching
```python
import wasi_http_async
wasi_http_async.patch_urllib()

# Now standard urllib works transparently
import urllib.request
response = urllib.request.urlopen('https://api.example.com/weather')
data = json.loads(response.read())
```

#### Option B: Global fetch() Function
```python
import wasi_http_async
wasi_http_async.install_fetch()

# JavaScript-style fetch() in global namespace
response = await fetch('https://api.example.com/weather')
data = await response.json()
```

#### Option C: requests Compatibility Layer
```python
from wasi_http_async import requests

# Drop-in replacement for requests library
response = requests.get('https://api.example.com/weather')
data = response.json()

# Also supports all common patterns
response = requests.post('https://api.example.com/data', 
                         json={'key': 'value'},
                         headers={'Authorization': 'Bearer token'})
```

#### Option D: Auto-Patching on Import
```python
# Simply importing auto-patches standard libraries
import wasi_http_async.auto_patch

# Now all these "just work"
import urllib.request
import http.client
response = urllib.request.urlopen('https://api.example.com/weather')
```

## Implementation Approach

### Dynamic Import Strategy
The library will dynamically discover WASI bindings generated by componentize-py:

```python
class _WasiBindings:
    """Lazy loader for WASI bindings."""
    
    def _ensure_loaded(self):
        # Try common module patterns
        for base in ['wit_world', 'app', 'component']:
            try:
                imports = __import__(f'{base}.imports', fromlist=[''])
                self._http_types = imports.wasi_http_types
                self._outgoing_handler = imports.outgoing_handler
                self._poll = imports.poll
                self._streams = imports.streams
                return
            except (ImportError, AttributeError):
                continue
        
        # Fallback to environment variable
        if custom := os.environ.get('WASI_HTTP_BINDINGS_MODULE'):
            return __import__(custom, fromlist=[''])
        
        raise ImportError("Cannot find WASI HTTP bindings...")
```

### Key Components
1. **PollLoop**: Custom asyncio event loop backed by wasi:io/poll
2. **Stream**: Async reader for response bodies
3. **FetchResponse**: Response object with .json(), .text(), .bytes() methods
4. **Resource Management**: Automatic cleanup of WASI resources

## Benefits
- **Reduces Complexity**: ~4 lines of code instead of 200+
- **Maintains Standards**: Pure WASI, works with any WASI runtime
- **Improves Maintainability**: Bug fixes in one place
- **Enables Ecosystem**: Others can build on solid HTTP foundation

## Migration Path
When WASI Preview 3 arrives with native async:
1. Library internally switches to native WASI async
2. API remains unchanged
3. User code needs no modifications

## Next Steps
1. Create standalone repository for wasi-http-async
2. Extract and refine code from this MCP example
3. Add comprehensive tests and examples
4. Publish to PyPI
5. Update MCP examples to use the library